  
  [1X2 [33X[0;0YProvided Functions[133X[101X
  
  
  [1X2.1 [33X[0;0YBasics[133X[101X
  
  [1X2.1-1 ZpOrderByMultiMatrices[101X
  
  [33X[1;0Y[29X[2XZpOrderByMultiMatrices[102X( [3Xp[103X, [3Xgens[103X ) [32X function[133X
  
  [33X[0;0YThis  function  creates an order over [22XZ_p[122X generated by the elements of [3Xgens[103X.
  [3Xgens[103X is supposed to be a list of lists of matrices with integer entries.[133X
  
  [33X[0;0YIt  is  highly  recommended  (and  necessary  for  many functions), that you
  install  endomorphism  rings  for the irreducible lattices after defining an
  order. See Section [14X2.2[114X for details.[133X
  
  [1X2.1-2 IrreducibleLattices[101X
  
  [33X[1;0Y[29X[2XIrreducibleLattices[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis   returns  list  of  irreducible  lattices,  one  for  each  Wedderburn
  component.  (Note  that  you  have  fixed  an  ordering  of  the  Wedderburn
  components upon creation of [3Xlambda[103X. This ordering will be used here.)[133X
  
  [1X2.1-3 SimpleModules[101X
  
  [33X[1;0Y[29X[2XSimpleModules[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YReturns  a  list  containing  the  simple  modules of the order [3Xlambda[103X. Once
  called, the ordering of the simple modules will remain fixed.[133X
  
  [1X2.1-4 DecompositionMatrix[101X
  
  [33X[1;0Y[29X[2XDecompositionMatrix[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YReturn  the  decomposition  matrix  of  the order [3Xlambda[103X. Rows are sorted as
  [2XIrreducibleLattices[102X ([14X2.1-2[114X), columns as [2XSimpleModules[102X ([14X2.1-3[114X).[133X
  
  [1X2.1-5 NameSimpleModulesByDims[101X
  
  [33X[1;0Y[29X[2XNameSimpleModulesByDims[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YGives  the  simple  modules  of  [3Xlambda[103X  names  according to their dimension
  (constisting of the dimension and some dashes to make the names unique). The
  names  will  (for instance) be carried over to a basic algebra by [2XBasicOrder[102X
  ([14X2.4-3[114X).[133X
  
  [1X2.1-6 NameSimpleModules[101X
  
  [33X[1;0Y[29X[2XNameSimpleModules[102X( [3Xlambda[103X, [3Xlst[103X ) [32X method[133X
  
  [33X[0;0Y[3Xlst[103X   is   supposed  to  be  a  list  of  strings  of  the  same  length  as
  [10XSimpleModules([3Xlambda[103X[10X)[110X.  This  will  assign  names  to  the simple modules of
  [3Xlambda[103X accordingly.[133X
  
  [1X2.1-7 SimpleNames[101X
  
  [33X[1;0Y[29X[2XSimpleNames[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YReturns  a  list containing the names of the simple modules of [3Xlambda[103X. If no
  names are set, this will produce an error.[133X
  
  [1X2.1-8 NameWedderburnComponentsByDims[101X
  
  [33X[1;0Y[29X[2XNameWedderburnComponentsByDims[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YGives the Wedderburn components of [3Xlambda[103X names according to their dimension
  (constisting  of  the  dimension  of the corresponding [22XQ_pâŠ—Î›[122X-module and some
  dashes  to  make the names unique). The names will (for instance) be carried
  over to a basic algebra by [2XBasicOrder[102X ([14X2.4-3[114X)..[133X
  
  [1X2.1-9 NameWedderburnComponents[101X
  
  [33X[1;0Y[29X[2XNameWedderburnComponents[102X( [3Xlambda[103X, [3Xlst[103X ) [32X method[133X
  
  [33X[0;0Y[3Xlst[103X   is   supposed  to  be  a  list  of  strings  of  the  same  length  as
  [10XIrreducibleLattices([3Xlambda[103X[10X)[110X.  This  will  assign  names  to  the  Wedderburn
  components modules of [3Xlambda[103X accordingly.[133X
  
  [1X2.1-10 ComponentNames[101X
  
  [33X[1;0Y[29X[2XComponentNames[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YReturns  a list containing the names of the Wedderburn components of [3Xlambda[103X.
  If no names are set, this will produce an error.[133X
  
  [1X2.1-11 DirectSumOfOrders[101X
  
  [33X[1;0Y[29X[2XDirectSumOfOrders[102X( [3Xlst[103X ) [32X method[133X
  
  [33X[0;0Y[3Xlst[103X  is  supposed to be a list of orders. This will return the direct sum of
  those orders.[133X
  
  [1X2.1-12 DirectSumOfOrders[101X
  
  [33X[1;0Y[29X[2XDirectSumOfOrders[102X( [3Xlambda1[103X, [3Xlambda2[103X ) [32X method[133X
  
  [33X[0;0YAs above, for just two orders.[133X
  
  [1X2.1-13 BlocksOfZpOrder[101X
  
  [33X[1;0Y[29X[2XBlocksOfZpOrder[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis  method  will return a list of lists of integers. Each list of integers
  corresponds to a block of [22XÎ›[122X, the integers indexing the Wedderburn components
  belonging to that block.[133X
  
  [1X2.1-14 ExtractWedderburnComponents[101X
  
  [33X[1;0Y[29X[2XExtractWedderburnComponents[102X( [3Xlambda[103X, [3Xlst[103X ) [32X method[133X
  
  [33X[0;0YGiven a list of integers in [3Xlst[103X indexing Wedderburn componnents, this method
  will  calculate  the  projection  of  [22XÎ›[122X  onto  those  components  (simply by
  projecting   the   generators).   Information   on   simple   and   ordinary
  representations  (if  present)  will  be  carried  over to the order that is
  returned.[133X
  
  [1X2.1-15 RModuleOverZpOrder[101X
  
  [33X[1;0Y[29X[2XRModuleOverZpOrder[102X( [3Xlambda[103X, [3Xrep[103X ) [32X function[133X
  
  [33X[0;0YThis  method  is  used  to  create  modules  from representations. [3Xlambda[103X is
  supposed  to  be an order, and [3Xrep[103X the images of the generators of [3Xlambda[103X in
  either  [22XF_p^nÃ— n[122X or [22XZ^nÃ— n âŠ‚ Z_p^nÃ— n[122X, i. e. [3Xrep[103X is a list of matrices. This
  method returns the corresponding module.[133X
  
  [1X2.1-16 ZeroRModule[101X
  
  [33X[1;0Y[29X[2XZeroRModule[102X( [3Xlambda[103X ) [32X function[133X
  
  [33X[0;0YReturns the zero-module over the order [3Xlambda[103X.[133X
  
  [1X2.1-17 Dimension[101X
  
  [33X[1;0Y[29X[2XDimension[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0YReturns the dimension of the module [3XM[103X.[133X
  
  [1X2.1-18 Generators[101X
  
  [33X[1;0Y[29X[2XGenerators[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis  returns  the  generators of [3Xlambda[103X (i. e. a list of lists of matrices,
  representing elements in the Wedderburn decomposition).[133X
  
  [1X2.1-19 Rep[101X
  
  [33X[1;0Y[29X[2XRep[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0Y[3XM[103X is supposed to be a (non-zero) module defined over an order [22XÎ›[122X. This method
  returns  the  images of the generators [22XÎ›[122X under the representation associated
  to [3XM[103X.[133X
  
  [1X2.1-20 ReduceModP[101X
  
  [33X[1;0Y[29X[2XReduceModP[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0Y[3XM[103X is supposed to be a module. This returns [22XM/pM[122X.[133X
  
  [1X2.1-21 SubmoduleByBasisNC[101X
  
  [33X[1;0Y[29X[2XSubmoduleByBasisNC[102X( [3XM[103X, [3XB[103X ) [32X method[133X
  
  [33X[0;0YGiven  a  module  [3XM[103X  of dimension [22Xn[122X and an [22XnÃ— n[122X matrix [3XB[103X whose rowspace is a
  submodule  of  [3XM[103X  (this  is  not  checked),  this  method  will  return  the
  corresponding submodule (as a module in the sense of this package).[133X
  
  [1X2.1-22 MaximalSubmoduleBases[101X
  
  [33X[1;0Y[29X[2XMaximalSubmoduleBases[102X( [3XM[103X[, [3XS[103X] ) [32X method[133X
  
  [33X[0;0YIf  [3XS[103X  is  not specified, this will return a list consisting of tuples [10X[B,T][110X
  (one  for  every  maximal  submodule  of [3XM[103X), where [10XB[110X is a basis matrix for a
  maximal  submodule  [22XN[122X  of  [3XM[103X,  and  [10XT[110X  is  a simple module isomorphic to the
  quotient [22X[3XM[103X/N[122X.[133X
  
  [33X[0;0YIf [3XS[103X is given (a simple module is expected here), this will return a list of
  basis matrices for all maximal submodules [22XN[122X with [22X[3XM[103X/N â‰… [3XS[103X[122X.[133X
  
  [33X[0;0YWhenever  the  zero  module is a maximal submodule, its basis matrix will be
  given by an empty list.[133X
  
  [1X2.1-23 MaximalSubmoduleBasesMTX[101X
  
  [33X[1;0Y[29X[2XMaximalSubmoduleBasesMTX[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0YThis returns a list of bases of all maximal submodules of the module [3XM[103X using
  the  [5XMeatAxe[105X that comes with [5XGAP[105X. This will only work if the generators of [22XÎ›[122X
  act   as   automorphisms  on  [3XM[103X.  Unsing  this  function  is  therefore  not
  recommended, use [2XMaximalSubmoduleBases[102X ([14X2.1-22[114X) instead.[133X
  
  [1X2.1-24 MaximalSubmodules[101X
  
  [33X[1;0Y[29X[2XMaximalSubmodules[102X( [3XM[103X[, [3XS[103X] ) [32X method[133X
  
  [33X[0;0YLike  [2XMaximalSubmoduleBases[102X  ([14X2.1-22[114X),  but  instead of basis matrices, this
  function will return modules in the sense of this package.[133X
  
  [1X2.1-25 Hom[101X
  
  [33X[1;0Y[29X[2XHom[102X( [3XM[103X, [3XN[103X ) [32X method[133X
  
  [33X[0;0YCalculates  a  basis for the homomorphism space between the modules [3XM[103X and [3XN[103X.
  As  any module in this package is canonically embedded in either some [22XZ_p^1Ã—
  n[122X or some [22XF_p^1Ã— n[122X, this method will always return a list of matrices either
  defined over the integers or over [10XGF(p)[110X.[133X
  
  [1X2.1-26 HomToSimpleNC[101X
  
  [33X[1;0Y[29X[2XHomToSimpleNC[102X( [3XM[103X, [3XS[103X ) [32X method[133X
  
  [33X[0;0YThis  is  basically  equivalent to [2XHom[102X ([14X2.1-25[114X), but it is assumed that [3XS[103X is
  simple.  This  function  uses the built-in [5XMeatAxe[105X of [5XGAP[105X, rendering it much
  faster than [2XHom[102X ([14X2.1-25[114X).[133X
  
  [1X2.1-27 HomForLattices[101X
  
  [33X[1;0Y[29X[2XHomForLattices[102X( [3XM[103X, [3XN[103X, [3Xopt[103X ) [32X function[133X
  
  [33X[0;0Y[3XM[103X  and  [3XN[103X  are  supposed to be lattices defined over an order [10Xlambda[110X. [3Xopt[103X is
  supposed  to  be one of [10X[ ][110X (useless), [10X[ 1 ][110X [10X[ 2 ][110X or [10X[ 1, 2 ][110X (although the
  ordering  of  the  list  is  irrelevant).  This function computes a basis of
  [22XHom([3XM[103X,[3XN[103X)[122X and will return a list containing the following:[133X
  
  [30X    [33X[0;6YIf  [22X1âˆˆ[3Xopt[103X[122X:  A  basis  of  [22XHom(M,N)[122X,  as  it  would  be returned by [2XHom[102X
        ([14X2.1-25[114X).[133X
  
  [30X    [33X[0;6YIf [22X2âˆˆ[3Xopt[103X[122X: A basis of [22XHom(M,N)[122X embedded in[133X
  
  
  [24X      [33X[0;6Y\bigoplus_{i}                        \textrm{End}_{\mathbb{Q}_p\otimes
        \Lambda}(\mathbb{Q}_p\otimes L_i)^{m_i\times n_i}[133X
  
  [124X
  
        [33X[0;6Ywhere [22XL_i[122X is the [22Xi[122X-th irreducible lattice of the order [22XÎ›[122X (over which [3XM[103X
        and  [3XN[103X  are  defined), as returned by [2XIrreducibleLattices[102X ([14X2.1-2[114X). The
        elements of [22XEnd_Q_pâŠ— Î›(Q_pâŠ— L_i)[122X are given by a (fixed) representation
        in some matrix ring over [22XQ_p[122X. [22Xm_i[122X resp. [22Xn_i[122X denote the multiplicity of
        [22XQ_pâŠ— L_i[122X as a summand of [22XQ_pâŠ— M[122X resp. [22XQ_pâŠ— N[122X.[133X
  
  [33X[0;0YThis  function  requires that some additional information about the lattices
  is  known, namely an embedding into a direct sum of irreducible lattices, as
  well as the endomorphism rings of the latter (which is usually the case). If
  [22X1âˆˆ[3Xopt[103X[122X,    you   may   check   that   this   information   is   present   via
  [10XIsBound(M!.embedding_into_irr_lats)[110X  and [10XIsBound(M!.order!.Qp_end_bases)[110X. If
  [22X2âˆˆ[3Xopt[103X[122X we additionally require [10XIsBound(M!.Qp_end_bases_smallmats)[110X.[133X
  
  [1X2.1-28 RadicalOfModule[101X
  
  [33X[1;0Y[29X[2XRadicalOfModule[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0YReturns  a tuple [10X[R, v][110X, where [10XR[110X is a module isomorphic to [22XRad([3XM[103X)[122X. [10Xv[110X will be
  a  list  of  non-negative integers, each [10Xv[i][110X indicating the multiplicity of
  [10XSimpleModules(...)[i][110X in [22X[3XM[103X/Rad([3XM[103X)[122X[133X
  
  [1X2.1-29 TopEpimorphism[101X
  
  [33X[1;0Y[29X[2XTopEpimorphism[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0Y[3XM[103X  is  supposed to be a module. This returns a tuple [22X[Q,Ï•,v,h][122X, where [22XQ[122X is a
  module isomorphic to [22X[3XM[103X / Rad [3XM[103X[122X and [22XÏ•: M â†’ Q[122X is an epimorphism. Furthermore [22Xv[122X
  is a list of the multiplicities of the different simple modules in [22XQ[122X. [22Xh[122X is a
  list of [22XEnd(S)[122X-bases of [22XHom(M, S)[122X (for all simple modules [22XS[122X).[133X
  
  [1X2.1-30 RadicalSeries[101X
  
  [33X[1;0Y[29X[2XRadicalSeries[102X( [3XM[103X, [3Xk[103X ) [32X method[133X
  
  [33X[0;0YCalculates  the  first  [3Xk[103X  radical layers of [3XM[103X. Returns a matrix [10XX[110X such that
  [10XX[j][i][110X   is   equal   to   the  multiplicity  of  [10XSimpleModules(...)[i][110X  in
  [22XRad^j-1(M)/Rad^j(M)[122X[133X
  
  [1X2.1-31 GramMatrixOfTrace[101X
  
  [33X[1;0Y[29X[2XGramMatrixOfTrace[102X( [3Xlambda[103X, [3Xu[103X ) [32X method[133X
  
  [33X[0;0Y[3Xu[103X is supposed to be a list of rationals, the same numer of entries as [3Xlambda[103X
  has  Wedderburn components (i. e. [3Xu[103X represents an element in [22XZ(Q_pâŠ—[3Xlambda[103X)[122X).
  Return  the  Gram-matrix  of  [3Xlambda[103X with respect to the trace bilinear form
  [22XT_[3Xu[103X: (a,b)â†¦ tr([3Xu[103Xab)[122X and the basis of [3Xlambda[103X returned by [2XGenerators[102X ([14X2.1-18[114X).[133X
  
  
  [1X2.2 [33X[0;0YEndomorphism Rings of the Irreducible Lattices[133X[101X
  
  [33X[0;0YMany  functions  in  this package require that the endomorphism rings of the
  irreducible  lattices of an order are known. Unfortunately, at this point we
  cannot effectively compute these in [5XGAP[105X.[133X
  
  [1X2.2-1 InstallTrivialEndomorphismRings[101X
  
  [33X[1;0Y[29X[2XInstallTrivialEndomorphismRings[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YCall this function if you [13Xknow[113X that [22XQ_p[122X is a splittiong field for [22XQ_pâŠ—[3Xlambda[103X[122X[133X
  
  [1X2.2-2 InstallEndomorphismRingsNC[101X
  
  [33X[1;0Y[29X[2XInstallEndomorphismRingsNC[102X( [3Xlambda[103X, [3Xlst[103X ) [32X method[133X
  
  [33X[0;0Y[3Xlst[103X is supposed to be a list of bases of endomorphism rings (i. e. a list of
  lists      of      matrices).      You     may     for     instance     call
  [10XInstallEndomorphismRingsNC(lambda,  List(IrreducibleLattices(lambda),  L  ->
  Hom(L,L)))[110X  to  compute  the  endomorphism  rings  in  [5XGAP[105X itself (this will
  however be horribly slow and excessive in memory usage).[133X
  
  [1X2.2-3 CalculateEndomorphismRingsByReynoldsNC[101X
  
  [33X[1;0Y[29X[2XCalculateEndomorphismRingsByReynoldsNC[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis  calculates  endomorphism  rings  using  the  Reynolds  [2XHomByReynoldsNC[102X
  ([14X???HomByReynoldsNC???[114X).  This  only  works  if  the  generators  of  [10Xlambda[110X
  generate a finite group (e.g. if [10Xlambda[110X is a group algebra).[133X
  
  [1X2.2-4 CalculateEndomorphismRingsWithMAGMA[101X
  
  [33X[1;0Y[29X[2XCalculateEndomorphismRingsWithMAGMA[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis  calculates  endomorphism  rings  using  [5XMAGMA[105X.  Use [2XSetMAGMAExecutable[102X
  ([14X2.2-5[114X) to specify the location of the [5XMAGMA[105X-executable on your system.[133X
  
  [1X2.2-5 SetMAGMAExecutable[101X
  
  [33X[1;0Y[29X[2XSetMAGMAExecutable[102X( [3Xcmd[103X ) [32X method[133X
  
  [33X[0;0YUse [10Xcmd[110X to run [5XMAGMA[105X.[133X
  
  [1X2.2-6 SetDebugOutput[101X
  
  [33X[1;0Y[29X[2XSetDebugOutput[102X( [3Xb[103X ) [32X method[133X
  
  [33X[0;0Y[10Xb[110X is expected to be a boolean. This turn debugging output on or off (as some
  computations  take  a long time, it can be useful to have some indication of
  how the computation is progressing).[133X
  
  
  [1X2.3 [33X[0;0YCondensation for Group Algebras[133X[101X
  
  [33X[0;0YIt  is  assumed throughout this section that the order [22XÎ›[122X we are dealing with
  is  a  group  algebra  (or  a block of) [22XZ_p G[122X for some finite group [22XG[122X. It is
  furthermore assumed that the generators of [22XÎ›[122X are elements of [22XG[122X.[133X
  
  [1X2.3-1 CondensationData[101X
  
  [33X[1;0Y[29X[2XCondensationData[102X( [3XG[103X, [3XH[103X[, [3Xchi[103X] ) [32X method[133X
  
  [33X[0;0Y[3XH[103X  is  supposed to be a [22Xp'[122X-subgroup of [3XG[103X. [3Xchi[103X is supposed to be a linear (i.
  e. one-dimensional) character of [3XH[103X. If [3Xchi[103X is not given, it will be taken as
  the  trivial  character. This method then computes a condensation idempotent
  [22Xe_Ï‡[122X  belonging  to  the pair [22X(H,Ï‡)[122X and a generating system for [22Xe_Ï‡ Z_p G e_Ï‡[122X
  (cf. [Noe05]).[133X
  
  [1X2.3-2 CondenseGroupRingNC[101X
  
  [33X[1;0Y[29X[2XCondenseGroupRingNC[102X( [3Xlambda[103X[, [3Xgens[103X], [3Xdata[103X ) [32X method[133X
  
  [33X[0;0YReturns  an  order  that  is  a  condensation  of [3Xlambda[103X with respect to the
  condensation  idempotent and system of generators fixed in [3Xdata[103X. [3Xdata[103X should
  have  been fixed via [10XCondensationData(...)[110X. The argument [3Xgens[103X should contain
  the images of the generators of [22XG[122X (as returned by [10XGeneratorsOfGroup(G)[110X) in [22XÎ›[122X
  (i.  e., [3Xgens[103X will be a list of lists of matrices). If [3Xgens[103X is not provided,
  it  will  be assumed that the images will be the generators of [22XÎ›[122X in the same
  order as they were given upon creation of [3Xlambda[103X.[133X
  
  [1X2.3-3 CondensationProperties[101X
  
  [33X[1;0Y[29X[2XCondensationProperties[102X( [3Xlambda[103X[, [3Xgens[103X], [3Xdata[103X ) [32X method[133X
  
  [33X[0;0YThis  function  is  analogous to [2XCondenseGroupRingNC[102X ([14X2.3-2[114X), except that it
  actually  just calculates which simple torsion-modules and which irreducible
  ordinary  representations  are  annihilated  by  the  selected  condensation
  idempotent.  You  may  use  this  to  check  wether the condensation will be
  faithful.[133X
  
  [1X2.3-4 CondenseMatricesNC[101X
  
  [33X[1;0Y[29X[2XCondenseMatricesNC[102X( [3XGgens[103X, [3XGreps[103X, [3Xdata[103X ) [32X function[133X
  
  [33X[0;0Y[3XGgens[103X is supposed to be a list of generators of a group [22XG[122X, [3XGreps[103X is supposed
  to  be  a list of matrices (defined over the integers) of the same length as
  [3XGgens[103X. The first to arguments should define a representation of the group in
  question,  i.  e.,  the  map  sending  [10X[3XGgens[103X[10X[i][110X  to  [10X[3XGreps[103X[10X[i][110X  extends  to a
  representation  of  [22XG[122X.  [3Xdata[103X  is  supposed  to  be  a  record  generated  by
  [2XCondensationData[102X  ([14X2.3-1[114X).  This  will  return  a list [10X[cgens, base, baseR][110X.
  [10Xcgens[110X  will contain the images of the generators of the condesed algebra (as
  fixed in [3Xdata[103X) under the condensed representation. [10Xbase[110X will be an embedding
  of  the  condensed  representation into the uncondensed, and [10XbaseR[110X will be a
  right inverse of [10Xbase[110X.[133X
  
  [1X2.3-5 CondenseMatricesWithEvalMapNC[101X
  
  [33X[1;0Y[29X[2XCondenseMatricesWithEvalMapNC[102X( [3Xhom[103X, [3Xdata[103X ) [32X function[133X
  
  [33X[0;0YJust like [2XCondenseMatricesNC[102X ([14X2.3-4[114X), but instead of the arguments [10XGgens[110X and
  [10XGreps[110X  you  specify  a function [3Xhom[103X which will return for any element in the
  group its image under the representation you wish to condense.[133X
  
  [1X2.3-6 CondenseTorsionRepNC[101X
  
  [33X[1;0Y[29X[2XCondenseTorsionRepNC[102X( [3XGgens[103X, [3XGreps[103X, [3Xp[103X, [3Xdata[103X ) [32X method[133X
  
  [33X[0;0YJust  like  [2XCondenseMatricesNC[102X  ([14X2.3-4[114X),  but  for [3Xp[103X-modular representations
  instead of integral ones.[133X
  
  
  [1X2.4 [33X[0;0YProjective Modules & Basic Algebras[133X[101X
  
  [1X2.4-1 ProjectiveIndecomposableLattices[101X
  
  [33X[1;0Y[29X[2XProjectiveIndecomposableLattices[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YCalculates the projective indecomposable lattices for [3Xlambda[103X. It will return
  a  list  cof  tuples,  where  the first entry is a projective indecomposable
  lattice, and the second one a simple torsion module (its head). Depending on
  the  dimensions  of  the projective indecomposables, running this method may
  take some time.[133X
  
  [1X2.4-2 BasicOrder[101X
  
  [33X[1;0Y[29X[2XBasicOrder[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis   calculates   a   basic   algebra   for   [3Xlambda[103X.  This  method  calls
  [2XProjectiveIndecomposableLattices[102X  ([14X2.4-1[114X),  and thus may take some time. The
  generators  of the result will form a basis of the order. Names given to the
  simple modules and Wedderburn components will be carried over accordingly.[133X
  
  [1X2.4-3 BasicOrder[101X
  
  [33X[1;0Y[29X[2XBasicOrder[102X( [3Xlst[103X ) [32X method[133X
  
  [33X[0;0Y[3Xlst[103X  should  be a list of projective indecomposable lattices. It will return
  an order isomorphic to[133X
  
  
  [24X[33X[0;6Y\bigoplus_{P, Q \in [3Xlst[103X} \textrm{Hom}(P, Q)[133X
  
  [124X
  
  [33X[0;0Yand  carry  over  names  accrodingly.  If  [3Xlst[103X  is  a list of all projective
  indecomposables, this is just equivalent to [10XBasicOrder(lambda)[110X.[133X
  
  [1X2.4-4 ProjectiveIndecomposableForBasicOrder[101X
  
  [33X[1;0Y[29X[2XProjectiveIndecomposableForBasicOrder[102X( [3Xlambda[103X, [3Xk[103X ) [32X method[133X
  
  [33X[0;0YThis   will  construct  the  projective  indecomposable  lattive  with  head
  [10XSimpleModules([3Xlambda[103X[10X)[k][110X.   This   method   just   uses   (in   contrast  to
  [2XProjectiveIndecomposableLattices[102X  ([14X2.4-1[114X))  the  regular  representation  of
  [3Xlambda[103X.  [3Xlambda[103X  should be an order constructed via [2XBasicOrder[102X ([14X2.4-3[114X) (this
  is not checked though).[133X
  
  [1X2.4-5 ProjectiveIndecomposableLatticesForBasicOrder[101X
  
  [33X[1;0Y[29X[2XProjectiveIndecomposableLatticesForBasicOrder[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis  behaves  like  [2XProjectiveIndecomposableLattices[102X ([14X2.4-1[114X), but will make
  use  of [2XProjectiveIndecomposableForBasicOrder[102X ([14X2.4-4[114X). In particular, [3Xlambda[103X
  should be an order constructed via [2XBasicOrder[102X ([14X2.4-3[114X).[133X
  
  [1X2.4-6 GeneratorsForBasicOrder[101X
  
  [33X[1;0Y[29X[2XGeneratorsForBasicOrder[102X( [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis  will  calculate  a  minimal  (w.r.t.  inclusion) generating system for
  [3Xlambda[103X  (that  will  be  preimages  of a basis of [22XÎ›/Jac(Î›)[122X and of a basis of
  [22XJac(Î›)Jac^2(Î›)+pÎ›[122X).  [3Xlambda[103X  should  be  an order constructed via [2XBasicOrder[102X
  ([14X2.4-3[114X)  (this is not checked though). This method returns a list consisting
  of  an  order  and  a  function. The order will in the mathematical sense be
  equal  to  [3Xlambda[103X, but will have the calculated generating set as its set of
  generators.  The function that is returned can be applied to modules defined
  over [3Xlambda[103X, and will return the same module defined over the order that was
  returned.[133X
  
  
  [1X2.5 [33X[0;0YComputing with Lattices[133X[101X
  
  [1X2.5-1 AllLattices[101X
  
  [33X[1;0Y[29X[2XAllLattices[102X( [3XL[103X ) [32X method[133X
  
  [33X[0;0YIf  [10XL[110X is a lattice over an order, this function computes representatives for
  the  isomorphism classes of full sublattices of [10XL[110X, or, equivalently, for all
  lattices in the [22XQ_p[122X-span of [10XL[110X.[133X
  
  [1X2.5-2 AllLatticesInd[101X
  
  [33X[1;0Y[29X[2XAllLatticesInd[102X( [3XL1[103X, [3XL2[103X ) [32X method[133X
  
  [33X[0;0YIf  [10XL1[110X  and  [10XL2[110X  are  lattices  over  the same order, this function computes
  representatives   for   the  isomorphism  classes  of  full  sublattices  of
  [10XDirectSumOfModules(L1,L2)[110X  whose  projection  down to [10XL1[110X and [10XL2[110X is all of [10XL1[110X
  and [10XL2[110X, respectively.[133X
  
  [1X2.5-3 IsomorphismRModules[101X
  
  [33X[1;0Y[29X[2XIsomorphismRModules[102X( [3XL1[103X, [3XL2[103X ) [32X method[133X
  
  [33X[0;0YIf  [10XL1[110X  and  [10XL2[110X  are  lattices over the same order, this function returns an
  isomorpism between [10XL1[110X and [10XL2[110X if the two lattices are isomorphic, and [10Xfail[110X if
  they are not.[133X
  
  [1X2.5-4 LatticeAlgorithm[101X
  
  [33X[1;0Y[29X[2XLatticeAlgorithm[102X( [3XM[103X, [3Xb[103X ) [32X function[133X
  
  [33X[0;0Y[3XM[103X is supposed to be an irreducible lattice (this will not be checked, but if
  it  is  not irreducible, this function will not terminate) and [3Xb[103X should be a
  boolean. What is returned depends on [3Xb[103X:[133X
  
  [30X    [33X[0;6Y[10X[3Xb[103X[10X  =  false[110X:  In  this  case, this function calculates representatives
        (possibly  with repetitions) of all isomorphism classes of irreducible
        lattices  in  [22XQ_pâŠ—  M[122X. It return a list of basis matrices for these as
        sublattices of [3XM[103X.[133X
  
  [30X    [33X[0;6Y[10X[3Xb[103X[10X = true[110X: In this case, this function will return only representatives
        of  lattices  with  simple  top.  The result will be a list of tuples,
        where  the  first  entry  is a basis matrix, and the second entry is a
        simple module (the top of the lattice).[133X
  
  [1X2.5-5 LatticesWithSimpleRadQuo[101X
  
  [33X[1;0Y[29X[2XLatticesWithSimpleRadQuo[102X( [3XM[103X ) [32X function[133X
  
  [33X[0;0Y[3XM[103X  is  supposed  to  be an irreducible lattice. This returns representatives
  (possibly  with  repititions) of all irreducible lattices with simple top in
  [22XQ_pâŠ—  M[122X.  It return a list of tuples, where the first entry is a lattice and
  the second one its top.[133X
  
  [1X2.5-6 GlueUpNC[101X
  
  [33X[1;0Y[29X[2XGlueUpNC[102X( [3XP[103X, [3XQ[103X, [3XS[103X ) [32X function[133X
  
  [33X[0;0Y[3XP[103X  and  [3XQ[103X  are  supposed  to  be  lattices, and [3XS[103X is supposed to be a simple
  module. Under the assumption that [3XP[103X and [3XQ[103X both have simple top isomorphic to
  [3XS[103X and furthermore [3XP[103X and [3XQ[103X have no non-zero common [22XZ_p[122X-torsionfree image this
  method  will  return  a  (full)  lattice  with  simple top [3XS[103X in [22X[3XP[103XâŠ• [3XQ[103X[122X. If the
  assumptions are not met, this method may not terminate.[133X
  
  
  [1X2.6 [33X[0;0YBasic Homological Algebra[133X[101X
  
  [1X2.6-1 ProjectiveCover[101X
  
  [33X[1;0Y[29X[2XProjectiveCover[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0YGiven  the  module  [3XM[103X, this returns a tuple [22X[P, Ï•][122X. Here [22XP[122X is the projective
  cover of [3XM[103X, and [22XÏ•[122X is an epimorphism [22XP â†’ [3XM[103X[122X.[133X
  
  [1X2.6-2 LiftHomomorphismNC[101X
  
  [33X[1;0Y[29X[2XLiftHomomorphismNC[102X( [3XM[103X, [3Xphi[103X, [3XN[103X, [3Xpsi[103X, [3XL[103X ) [32X method[133X
  
  [33X[0;0Y[3XM[103X,  [3XN[103X and [3XL[103X are supposed to be modules. [3Xphi[103X is supposed to be a homomorphism
  [22X[3XM[103Xâ†’[3XL[103X[122X. [3Xpsi[103X is supposed to be a homomorphism [22X[3XN[103Xâ†’[3XL[103X[122X. This return a homomorphism [22XX:
  M  â†’  N[122X such that [22XX â‹… [3Xpsi[103X = [3Xphi[103X[122X. If no such [22XX[122X exists, [10Xfail[110X is returned. Note
  that  all  homomorphisms  are represented by matrices, and it is not checked
  wether the given matrices actually are homomorphisms.[133X
  
  [1X2.6-3 LiftHomomorphismToDirectSumNC[101X
  
  [33X[1;0Y[29X[2XLiftHomomorphismToDirectSumNC[102X( [3Xlst[103X, [3Xsvec[103X, [3Xphi[103X, [3XN[103X, [3Xpsi[103X, [3XL[103X ) [32X method[133X
  
  [33X[0;0Y[3Xlst[103X  is  supposed to be a list of lattices. [3Xsvec[103X is supposed to be a list of
  indices.       This       is       then      equivalent      to      calling
  [10XLiftHomomorphismNC(DirectSumOfModules(List(svec, i -> lst[i])), phi, N, psi,
  L)[110X but it is actually a lot faster.[133X
  
  [1X2.6-4 HellerTranslate[101X
  
  [33X[1;0Y[29X[2XHellerTranslate[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0YGiven  a  module  [3XM[103X,  this  computes its Heller translate. Note that this is
  always going to return a lattice.[133X
  
  [1X2.6-5 HellerTranslateModular[101X
  
  [33X[1;0Y[29X[2XHellerTranslateModular[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0YGiven  a  torsion module [3XM[103X, this computes its modular Heller translate. That
  is,  the Heller translate in the module category of [22XF_p âŠ— Î›[122X, where [22XÎ›[122X denotes
  the  order over which [3XM[103X is defined. Note that this is always going to return
  a torsion module.[133X
  
  
  [1X2.7 [33X[0;0YInput/Output[133X[101X
  
  [1X2.7-1 PrintAsFunction[101X
  
  [33X[1;0Y[29X[2XPrintAsFunction[102X( [3XX[103X ) [32X method[133X
  
  [33X[0;0YOutputs a function that will create the module or order [3XX[103X. Usually you would
  use [2XSaveAsFunction[102X ([14X2.7-2[114X) directly.[133X
  
  [1X2.7-2 SaveAsFunction[101X
  
  [33X[1;0Y[29X[2XSaveAsFunction[102X( [3Xfilename[103X, [3XX[103X ) [32X method[133X
  
  [33X[0;0YSaves  the module or order [3XX[103X to the file [3Xfilename[103X (which will be overwritten
  in  case  it exists). You can then read that file using [2XReadOrder[102X ([14X2.7-4[114X) or
  [2XReadModule[102X ([14X2.7-5[114X).[133X
  
  [1X2.7-3 SaveAsRecord[101X
  
  [33X[1;0Y[29X[2XSaveAsRecord[102X( [3Xfilename[103X, [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YThis writes the order [3Xlambda[103X to the file [3Xfilename[103X (which will be overwritten
  in case it exists). The file will then contain a [5XGAP[105X-function that returns a
  record.  The  content  of  that  file  cannot  be  turned back into an order
  directly using this package, so usually you would want to use [2XSaveAsFunction[102X
  ([14X2.7-2[114X). However, the advantage of [2XSaveAsRecord[102X is that you do not need this
  package to read the file that it produces.[133X
  
  [1X2.7-4 ReadOrder[101X
  
  [33X[1;0Y[29X[2XReadOrder[102X( [3Xfilename[103X ) [32X method[133X
  
  [33X[0;0YReturns  an  order that is identical to the one that was written to [3Xfilename[103X
  using [2XSaveAsFunction[102X ([14X2.7-2[114X).[133X
  
  [1X2.7-5 ReadModule[101X
  
  [33X[1;0Y[29X[2XReadModule[102X( [3Xfilename[103X, [3Xlambda[103X ) [32X method[133X
  
  [33X[0;0YReturns  a  module that is identical to the one that was written to [3Xfilename[103X
  using  [2XSaveAsFunction[102X  ([14X2.7-2[114X).  That module will be defined over [3Xlambda[103X (so
  when  you  save  a  module be sure to always save the order over which it is
  defined as well).[133X
  
  
  [1X2.8 [33X[0;0YSymmetric Groups[133X[101X
  
  [1X2.8-1 ZpSn[101X
  
  [33X[1;0Y[29X[2XZpSn[102X( [3Xp[103X, [3Xn[103X ) [32X function[133X
  
  [33X[0;0YThis  returns  the  order  [22XZ_p  Î£_n[122X.  The Wedderburn components are named by
  partitions,  and  sorted  descending  with  respect  to  the lexicographical
  ordering.  The  simple modules are named after their dimensions (it will not
  be  too  hard  to  find the corresponding [3Xp[103X-regular partitions, though). The
  lattices   returned  by  [2XIrreducibleLattices[102X  ([14X2.1-2[114X)  will  be  the  Specht
  lattices.[133X
  
  [1X2.8-2 ZpSnWedderburnComponentsNC[101X
  
  [33X[1;0Y[29X[2XZpSnWedderburnComponentsNC[102X( [3Xp[103X, [3Xpart[103X ) [32X function[133X
  
  [33X[0;0Y[3Xpart[103X  is  supposed to be a non-empty list of pairwise distinct partitions of
  the same number [22Xn[122X (this will however not be checked). Returns the projection
  of  [22XZ_p  Î£_n[122X  on the Wedderburn components labeled by the partitons in [3Xpart[103X.
  Otherwise this behaves like [2XZpSn[102X ([14X2.8-1[114X).[133X
  
  [1X2.8-3 NaturalSpechtRepresentation[101X
  
  [33X[1;0Y[29X[2XNaturalSpechtRepresentation[102X( [3Xlambda[103X ) [32X function[133X
  
  [33X[0;0Y[3Xlambda[103X  is  supposed  to  be  a  partition  of some positive integer [10Xn[110X. This
  function  returns a group homomorphism from [10XSymmetricGroup(n)[110X into a general
  linear group over the integers. To be more precise, this function implements
  Young's "natural" representation for the Specht module [22XS^Î»[122X. See Example 25.2
  in [Jam78] for details.[133X
  
  [1X2.8-4 PartitionAsString[101X
  
  [33X[1;0Y[29X[2XPartitionAsString[102X( [3Xmu[103X ) [32X method[133X
  
  [33X[0;0YGiven  a  partition  [3Xmu[103X, this returns a string representing [3Xmu[103X. For instance
  [10XPartitionAsString([3,2,1,1])[110X returns [10X"(3,2,1^{2})"[110X.[133X
  
  
  [1X2.9 [33X[0;0YExperimental Functionality[133X[101X
  
  [33X[0;0YThe  functions  in  this  section  are  somewhat  experimental and only work
  reasonably  well  in  small  examples.  All  functions  in  this  section do
  furthermore require that the generators of the given orders form a basis.[133X
  
  [1X2.9-1 SelfdualSuborders[101X
  
  [33X[1;0Y[29X[2XSelfdualSuborders[102X( [3Xlambda[103X, [3Xu[103X ) [32X method[133X
  
  [33X[0;0YGiven  an element [22Xu[122X in [22XZ(Q_pâŠ—[3Xlambda[103X)[122X, this returns all (ismomorphism classes
  of)  orders  contained in [3Xlambda[103X that are selfdual with respect to the trace
  bilinear form [22XT_u[122X (same as in [2XGramMatrixOfTrace[102X ([14X2.1-31[114X)).[133X
  
  [1X2.9-2 AreConjugate[101X
  
  [33X[1;0Y[29X[2XAreConjugate[102X( [3Xlambda[103X, [3Xgamma[103X ) [32X method[133X
  
  [33X[0;0YGiven two orders [3Xlambda[103X and [3Xgamma[103X in the same semisimple [22XQ_p[122X-algebra [22XA[122X, this
  decides  wether  the  two  are  conjugate  (or,  equivalently, isomorphic as
  algebras over the center of [22XA[122X).[133X
  
  
  [1X2.10 [33X[0;0YPretty Output[133X[101X
  
  [1X2.10-1 PrintDecompositionMatrixAsLatex[101X
  
  [33X[1;0Y[29X[2XPrintDecompositionMatrixAsLatex[102X( [3XA[103X ) [32X function[133X
  
  [33X[0;0YGiven  an  order  [10XA[110X,  this  function prints the decomposition matrix of [10XA[110X as
  [5XLaTeX[105X-code (including information on names and dimensions of modules).[133X
  
  [1X2.10-2 PrintBasisOfOrderAsMarkdown[101X
  
  [33X[1;0Y[29X[2XPrintBasisOfOrderAsMarkdown[102X( [3XA[103X ) [32X function[133X
  
  [33X[0;0YGiven a basic order [10XA[110X, this function prints a basis of [10XA[110X as [5XJupyter[105X-markdown
  code (can easily be turned into [5XLaTeX[105X-code).[133X
  
  [1X2.10-3 JupyterDisplayDecompositionMatrix[101X
  
  [33X[1;0Y[29X[2XJupyterDisplayDecompositionMatrix[102X( [3XA[103X ) [32X function[133X
  [33X[1;0Y[29X[2XJupyterDisplayBasisOfOrder[102X( [3XA[103X ) [32X function[133X
  [33X[1;0Y[29X[2XJupyterDisplayMultiMatrix[102X( [3Xlst[103X ) [32X function[133X
  
  [33X[0;0YIf [5XGAP[105X is run in a Jupyter notebook, this will render the respective objects
  in the notebook.[133X
  
  
  [1X2.11 [33X[0;0YMiscellaneous Other Functions[133X[101X
  
  [1X2.11-1 SpinningAlgorithmNC[101X
  
  [33X[1;0Y[29X[2XSpinningAlgorithmNC[102X( [3Xlst[103X ) [32X function[133X
  
  [33X[0;0YGiven  a  list [10Xlst[110X of rational square matrices that generate a [22XZ[122X-order, this
  function  return  a  list  [10Xret[110X  of  integer  square matrices such that [22XT^-1â‹…
  textttlst[i] â‹… T = textttret[i] âˆ€ i[122X for an invertible rational matrix [22XT[122X.[133X
  
  [1X2.11-2 UnFlattenMultiMatrixNC[101X
  
  [33X[1;0Y[29X[2XUnFlattenMultiMatrixNC[102X( [3Xlst[103X, [3Xdimvec[103X ) [32X function[133X
  
  [33X[0;0YWhen    [22XA=[A_1,...,A_k][122X    is    a    list   of   matrices   of   dimensions
  [22X[3Xdimvec[103X=[n_1,...,n_k][122X,   this   method   is   inverse  to  [10XFlat(...)[110X,  i.  e.
  [10XUnFlattenMultiMatrixNC(Flat(A), dimvec) = A[110X.[133X
  
  [1X2.11-3 DiagonalJoin[101X
  
  [33X[1;0Y[29X[2XDiagonalJoin[102X( [3Xlst[103X ) [32X method[133X
  
  [33X[0;0Y[3Xlst[103X  is  supposed  to  be  a  list  [22X[A_1,...,A_k][122X,  and  the  method returns
  [22XDiag(A_1,...,A_k)[122X[133X
  
  [1X2.11-4 DiagonalJoin[101X
  
  [33X[1;0Y[29X[2XDiagonalJoin[102X( [3XA[103X, [3XB[103X ) [32X method[133X
  
  [33X[0;0YThe same as above, for just two matrices.[133X
  
  [1X2.11-5 Valuation[101X
  
  [33X[1;0Y[29X[2XValuation[102X( [3Xr[103X, [3Xp[103X ) [32X method[133X
  
  [33X[0;0YReturns the [3Xp[103X-valuation of the rational number [3Xr[103X (the built-in method in [5XGAP[105X
  only covers integers).[133X
  
  [1X2.11-6 RightInverse[101X
  
  [33X[1;0Y[29X[2XRightInverse[102X( [3XM[103X ) [32X method[133X
  
  [33X[0;0YComputes  a right inverse of the matrix [3XM[103X (over [10XDefaultFieldOfMatrix(M)[110X). If
  [3XM[103X has no right inverse, it returns [10Xfail[110X.[133X
  
