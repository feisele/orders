% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{The \textsf{orders} Package\mbox{}}}\\
\vfill

\hypersetup{pdftitle=The \textsf{orders} Package}
\markright{\scriptsize \mbox{}\hfill The \textsf{orders} Package \hfill\mbox{}}
{\Huge ( Version 1.0 )\mbox{}}\\[1cm]
{July 2018\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Florian Eisele  \mbox{}}}\\
\hypersetup{pdfauthor=Florian Eisele  }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Florian Eisele  }  Email: \href{mailto://florian.eisele@city.ac.uk} {\texttt{florian.eisele@city.ac.uk}}\\
  Homepage: \href{https://feisele.github.io} {\texttt{https://feisele.github.io}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
{\copyright} 2018 by Florian Eisele.\mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  The \textsf{orders}-package deals with $\mathbb{Z}_p$-orders $\Lambda$ in semisimple $\mathbb Q_p$-algebras $A$, where $\mathbb Z_p$ denotes the $p$-adic integers. Its original purpose was to compute the projective
indecomposable lattices of such orders, and from those a basic algebra of $\Lambda$. In addition, the package offers some functionality to deal with arbitrary
lattices over $\Lambda$. In particular, it can compute representatives for the isomorphism classes of
all $\Lambda$-lattices inside a given $A$-module $V$, compute homomorphism spaces betwen lattices and check whether two $\Lambda$-lattices $L_1$ and $L_2$ are isomorphic. 
\section{\textcolor{Chapter }{General Design \& Limitations of this Package}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X822633517F9886C3}{}
{
 An order $\Lambda$ can be created using the function \texttt{ZpOrderByMultiMatrices} (\ref{ZpOrderByMultiMatrices}). The following data needs to be specified: 
\begin{itemize}
\item  A prime $p$ 
\item  A list $[g_1,\ldots,g_k]$ where each $g_i$ is a list of matrices over $\mathbb Z$. The list $g_i$ represents a generator of the order. More precisely, $g_i[l]$ is supposed to be the image of the $i$-th generator under the $l$-th irreducible $\mathbb{Q}_p$-representation of $\mathbb{Q}_p \otimes \Lambda$. 
\end{itemize}
 A few remarks are in order here: 
\begin{itemize}
\item  We assume that we know the Wedderburn decomposition of $\mathbb{Q}_p\otimes\Lambda$. When dealing with group algebras, this means that we need to know the
irreducible representations of the group over $\mathbb Q_p$, which is a non-trivial problem. For group algebras of finite groups, we
might be able to use \texttt{IrreducibleRepresentations}, but there is no guarantee that these representations end up being defined
over a small enough field. The condition that the images of the generators of $\Lambda$ are integral means in particular that we single out one particular irreducible
lattice as a "standard lattice" in the corresponding simple $\mathbb{Q}_p\otimes\Lambda$-module. For the purposes of this package it does not matter though which
lattice we choose. 
\item  While we consider $A$ as a $\mathbb Q_p$-algebra, we actually ask for the images of the generators of $A$ under the irreducible representations of $A$ to be matrices over $\mathbb Q$. In the case of group algebras of finite groups, it often happens that the
irreducible representations over $\mathbb Q$ stay irreducible over $\mathbb Q_p$, in which case we get generators of the desired form. Integral spinning will
the allow us to turn this collection of matrices over the rationals into
matrices over the integers. 
\end{itemize}
 None of the issues mentioned above arise for $\Lambda=\mathbb Z_p S_n$, where $S_n$ denotes the symmetric group on $n$ letters. Therefore symmetric groups are particularly easy amenable to the
methods in this package, and we provide some functionality specific to
symmetric groups.

 Once we have defined an order in the sense of this package, we can define
modules over it. This package supports modules that are either $\Lambda$-lattices (i. e. free as $\mathbb{Z}_p$-modules) or $p$-torsion modules (i. e. $\mathbb{F}_p$-vector spaces with a $\Lambda$-action). Other torsion types are not supported. Modules are internally
represented by the images of the generators $g_1,...,g_k$ of $\Lambda$ in some matrix ring. For lattices we also store (if known) an embedding in a
direct sum of irreducible lattices. }

 
\section{\textcolor{Chapter }{Basic Data Structures}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X7BBE7EAB7AD8B184}{}
{
 This package handles two types of objects: orders and modules over orders.
Although you can define modules "by hand", the general idea is that you define
an order (which essentially means that you provide a set of irreducible
integral representations) and use the functions provided in this package to
construct further modules (e. g. simple modules, projectives, radicals of
modules) and homomorphism spaces between them. 
\subsection{\textcolor{Chapter }{IsZpOrder}}\logpage{[ 1, 2, 1 ]}
\hyperdef{L}{X8682EFEF7AC0A66A}{}
{
 A $\mathbb{Z}_p$-order in a semisimple $\mathbb{Q}_p$-algebra is represented by an oject in the category \texttt{IsZpOrder}. You may create such an object using \texttt{ZpOrderByMultiMatrices} (\ref{ZpOrderByMultiMatrices}). Such an object (representing an order $\Lambda$) is used to store information about: 
\begin{itemize}
\item  The irreducible representations of $\mathbb{Q}_p\otimes\Lambda$. 
\item  The endomorphism rings of the irreducible lattices (these are crucial for
efficient computation). At present, we cannot compute these efficiently in \textsf{GAP} itself, unless the generators of $\Lambda$ generate a finite group (in which case we can use \texttt{CalculateEndomorphismRingsByReynoldsNC} (\ref{CalculateEndomorphismRingsByReynoldsNC})). If you know that $\mathbb{Q}_p$ is a splitting field for $\mathbb{Q}_p\otimes\Lambda$ you can use \texttt{InstallTrivialEndomorphismRings} (\ref{InstallTrivialEndomorphismRings}). If you have a recent version of \textsf{Magma} available, you can also compute these endomorphism rings using \texttt{CalculateEndomorphismRingsWithMAGMA} (\ref{CalculateEndomorphismRingsWithMAGMA}). If you have calculated these endomorphism rings by other means, you can use \texttt{InstallEndomorphismRingsNC} (\ref{InstallEndomorphismRingsNC}) to install them. 
\item  The simple modules and the decomposition matrix of $\Lambda$. 
\end{itemize}
 When we refer to an "order", we will always mean an object of this type. }

 
\subsection{\textcolor{Chapter }{IsRModuleOverZpOrder}}\logpage{[ 1, 2, 2 ]}
\hyperdef{L}{X80E3E1627FA611FC}{}
{
 An object on the category \texttt{IsRModuleOverZpOrder} represents a right module over an order. All modules in this package are right
modules, so we will usually just call them modules. Modules are represented by
a linear representation. The only exception is the zero module. This package
supports three types of modules: 
\begin{itemize}
\item  \emph{Lattices}: Lattices are represented by a linear representation over $\mathbb{Z}_p$. For practical purposes the package does expect the images of the generators
of the order over which the lattice is defined to lie in $\mathbb{Z}^{n\times n}$ (this constitutes no further theoretical restriction). Lattices have the
property \texttt{IsRLatticeOverZpOrder}. Lattices in this package may also store an embedding into a direct sum of
irreducible lattices, which is crucial for efficient computation. If lattices
are constructed from other lattices using functions from this package, the
functions will always compute and store such an embeding for all lattices they
create. 
\item  \emph{$p$-torsion modules}: These are given by the images of the generators of the order in some matrix
ring over $\mathbb{F}_p$. $p$-torsion modules have the property \texttt{IsRModuleOverZpOrderModp}. 
\item  \emph{The zero module}: This one has the properties \texttt{IsZeroRModuleRep} and \texttt{IsZero}. 
\end{itemize}
 }

 }

 
\section{\textcolor{Chapter }{Examples}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
 \href{example.html} {An example session can be found here.} }

 }

 
\chapter{\textcolor{Chapter }{Provided Functions}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X846FF7C17F240B96}{}
{
 
\section{\textcolor{Chapter }{Basics}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X868F7BAB7AC2EEBC}{}
{
 

\subsection{\textcolor{Chapter }{ZpOrderByMultiMatrices}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X856274FC87141FBD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ZpOrderByMultiMatrices({\mdseries\slshape p, gens})\index{ZpOrderByMultiMatrices@\texttt{ZpOrderByMultiMatrices}}
\label{ZpOrderByMultiMatrices}
}\hfill{\scriptsize (function)}}\\


 This function creates an order over $\mathbb{Z}_p$ generated by the elements of \mbox{\texttt{\mdseries\slshape gens}}. \mbox{\texttt{\mdseries\slshape gens}} is supposed to be a list of lists of matrices with integer entries.

 It is highly recommended (and necessary for many functions), that you install
endomorphism rings for the irreducible lattices after defining an order. See
Section \ref{Endo} for details. }

 

\subsection{\textcolor{Chapter }{IrreducibleLattices}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X7D425D657F5F2B5F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IrreducibleLattices({\mdseries\slshape lambda})\index{IrreducibleLattices@\texttt{IrreducibleLattices}}
\label{IrreducibleLattices}
}\hfill{\scriptsize (method)}}\\


 This returns list of irreducible lattices, one for each Wedderburn component.
(Note that you have fixed an ordering of the Wedderburn components upon
creation of \mbox{\texttt{\mdseries\slshape lambda}}. This ordering will be used here.) }

 

\subsection{\textcolor{Chapter }{SimpleModules}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X7C61261F7C5E53B8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SimpleModules({\mdseries\slshape lambda})\index{SimpleModules@\texttt{SimpleModules}}
\label{SimpleModules}
}\hfill{\scriptsize (method)}}\\


 Returns a list containing the simple modules of the order \mbox{\texttt{\mdseries\slshape lambda}}. Once called, the ordering of the simple modules will remain fixed. }

 

\subsection{\textcolor{Chapter }{DecompositionMatrix}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X84701640811D2345}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DecompositionMatrix({\mdseries\slshape lambda})\index{DecompositionMatrix@\texttt{DecompositionMatrix}}
\label{DecompositionMatrix}
}\hfill{\scriptsize (method)}}\\


 Return the decomposition matrix of the order \mbox{\texttt{\mdseries\slshape lambda}}. Rows are sorted as \texttt{IrreducibleLattices} (\ref{IrreducibleLattices}), columns as \texttt{SimpleModules} (\ref{SimpleModules}). }

 

\subsection{\textcolor{Chapter }{NameSimpleModulesByDims}}
\logpage{[ 2, 1, 5 ]}\nobreak
\hyperdef{L}{X7B131FA581D6F41C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NameSimpleModulesByDims({\mdseries\slshape lambda})\index{NameSimpleModulesByDims@\texttt{NameSimpleModulesByDims}}
\label{NameSimpleModulesByDims}
}\hfill{\scriptsize (method)}}\\


 Gives the simple modules of \mbox{\texttt{\mdseries\slshape lambda}} names according to their dimension (constisting of the dimension and some
dashes to make the names unique). The names will (for instance) be carried
over to a basic algebra by \texttt{BasicOrder} (\ref{BasicOrder}). }

 

\subsection{\textcolor{Chapter }{NameSimpleModules}}
\logpage{[ 2, 1, 6 ]}\nobreak
\hyperdef{L}{X7858621880AACFC9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NameSimpleModules({\mdseries\slshape lambda, lst})\index{NameSimpleModules@\texttt{NameSimpleModules}}
\label{NameSimpleModules}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape lst}} is supposed to be a list of strings of the same length as \texttt{SimpleModules(\mbox{\texttt{\mdseries\slshape lambda}})}. This will assign names to the simple modules of \mbox{\texttt{\mdseries\slshape lambda}} accordingly. }

 

\subsection{\textcolor{Chapter }{SimpleNames}}
\logpage{[ 2, 1, 7 ]}\nobreak
\hyperdef{L}{X7D6D80837D5BAE4B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SimpleNames({\mdseries\slshape lambda})\index{SimpleNames@\texttt{SimpleNames}}
\label{SimpleNames}
}\hfill{\scriptsize (method)}}\\


 Returns a list containing the names of the simple modules of \mbox{\texttt{\mdseries\slshape lambda}}. If no names are set, this will produce an error. }

 

\subsection{\textcolor{Chapter }{NameWedderburnComponentsByDims}}
\logpage{[ 2, 1, 8 ]}\nobreak
\hyperdef{L}{X823D95757CCF12A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NameWedderburnComponentsByDims({\mdseries\slshape lambda})\index{NameWedderburnComponentsByDims@\texttt{NameWedderburnComponentsByDims}}
\label{NameWedderburnComponentsByDims}
}\hfill{\scriptsize (method)}}\\


 Gives the Wedderburn components of \mbox{\texttt{\mdseries\slshape lambda}} names according to their dimension (constisting of the dimension of the
corresponding $\mathbb{Q}_p\otimes\Lambda$-module and some dashes to make the names unique). The names will (for
instance) be carried over to a basic algebra by \texttt{BasicOrder} (\ref{BasicOrder}).. }

 

\subsection{\textcolor{Chapter }{NameWedderburnComponents}}
\logpage{[ 2, 1, 9 ]}\nobreak
\hyperdef{L}{X84135ED17EDAB54C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NameWedderburnComponents({\mdseries\slshape lambda, lst})\index{NameWedderburnComponents@\texttt{NameWedderburnComponents}}
\label{NameWedderburnComponents}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape lst}} is supposed to be a list of strings of the same length as \texttt{IrreducibleLattices(\mbox{\texttt{\mdseries\slshape lambda}})}. This will assign names to the Wedderburn components modules of \mbox{\texttt{\mdseries\slshape lambda}} accordingly. }

 

\subsection{\textcolor{Chapter }{ComponentNames}}
\logpage{[ 2, 1, 10 ]}\nobreak
\hyperdef{L}{X85361C2087965A86}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ComponentNames({\mdseries\slshape lambda})\index{ComponentNames@\texttt{ComponentNames}}
\label{ComponentNames}
}\hfill{\scriptsize (method)}}\\


 Returns a list containing the names of the Wedderburn components of \mbox{\texttt{\mdseries\slshape lambda}}. If no names are set, this will produce an error. }

 

\subsection{\textcolor{Chapter }{DirectSumOfOrders}}
\logpage{[ 2, 1, 11 ]}\nobreak
\hyperdef{L}{X861A1E2B834F862A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DirectSumOfOrders({\mdseries\slshape lst})\index{DirectSumOfOrders@\texttt{DirectSumOfOrders}}
\label{DirectSumOfOrders}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape lst}} is supposed to be a list of orders. This will return the direct sum of those
orders. }

 

\subsection{\textcolor{Chapter }{DirectSumOfOrders}}
\logpage{[ 2, 1, 12 ]}\nobreak
\hyperdef{L}{X861A1E2B834F862A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DirectSumOfOrders({\mdseries\slshape lambda1, lambda2})\index{DirectSumOfOrders@\texttt{DirectSumOfOrders}}
\label{DirectSumOfOrders}
}\hfill{\scriptsize (method)}}\\


 As above, for just two orders. }

 

\subsection{\textcolor{Chapter }{BlocksOfZpOrder}}
\logpage{[ 2, 1, 13 ]}\nobreak
\hyperdef{L}{X780C417B7C94AB50}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BlocksOfZpOrder({\mdseries\slshape lambda})\index{BlocksOfZpOrder@\texttt{BlocksOfZpOrder}}
\label{BlocksOfZpOrder}
}\hfill{\scriptsize (method)}}\\


 This method will return a list of lists of integers. Each list of integers
corresponds to a block of $\Lambda$, the integers indexing the Wedderburn components belonging to that block. }

 

\subsection{\textcolor{Chapter }{ExtractWedderburnComponents}}
\logpage{[ 2, 1, 14 ]}\nobreak
\hyperdef{L}{X7BF4A4AC868C59DA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ExtractWedderburnComponents({\mdseries\slshape lambda, lst})\index{ExtractWedderburnComponents@\texttt{ExtractWedderburnComponents}}
\label{ExtractWedderburnComponents}
}\hfill{\scriptsize (method)}}\\


 Given a list of integers in \mbox{\texttt{\mdseries\slshape lst}} indexing Wedderburn componnents, this method will calculate the projection of $\Lambda$ onto those components (simply by projecting the generators). Information on
simple and ordinary representations (if present) will be carried over to the
order that is returned. }

 

\subsection{\textcolor{Chapter }{RModuleOverZpOrder}}
\logpage{[ 2, 1, 15 ]}\nobreak
\hyperdef{L}{X7D266110849A590E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{RModuleOverZpOrder({\mdseries\slshape lambda, rep})\index{RModuleOverZpOrder@\texttt{RModuleOverZpOrder}}
\label{RModuleOverZpOrder}
}\hfill{\scriptsize (function)}}\\


 This method is used to create modules from representations. \mbox{\texttt{\mdseries\slshape lambda}} is supposed to be an order, and \mbox{\texttt{\mdseries\slshape rep}} the images of the generators of \mbox{\texttt{\mdseries\slshape lambda}} in either $\mathbb{F}_p^{n\times n}$ or $\mathbb{Z}^{n\times n} \subset \mathbb{Z}_p^{n\times n}$, i. e. \mbox{\texttt{\mdseries\slshape rep}} is a list of matrices. This method returns the corresponding module. }

 

\subsection{\textcolor{Chapter }{ZeroRModule}}
\logpage{[ 2, 1, 16 ]}\nobreak
\hyperdef{L}{X7876438B86F89DBE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ZeroRModule({\mdseries\slshape lambda})\index{ZeroRModule@\texttt{ZeroRModule}}
\label{ZeroRModule}
}\hfill{\scriptsize (function)}}\\


 Returns the zero-module over the order \mbox{\texttt{\mdseries\slshape lambda}}. }

 

\subsection{\textcolor{Chapter }{Dimension}}
\logpage{[ 2, 1, 17 ]}\nobreak
\hyperdef{L}{X7E6926C6850E7C4E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Dimension({\mdseries\slshape M})\index{Dimension@\texttt{Dimension}}
\label{Dimension}
}\hfill{\scriptsize (method)}}\\


 Returns the dimension of the module \mbox{\texttt{\mdseries\slshape M}}. }

 

\subsection{\textcolor{Chapter }{Generators}}
\logpage{[ 2, 1, 18 ]}\nobreak
\hyperdef{L}{X7BD5B55C802805B4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Generators({\mdseries\slshape lambda})\index{Generators@\texttt{Generators}}
\label{Generators}
}\hfill{\scriptsize (method)}}\\


 This returns the generators of \mbox{\texttt{\mdseries\slshape lambda}} (i. e. a list of lists of matrices, representing elements in the Wedderburn
decomposition). }

 

\subsection{\textcolor{Chapter }{Rep}}
\logpage{[ 2, 1, 19 ]}\nobreak
\hyperdef{L}{X7884D657865C7D03}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Rep({\mdseries\slshape M})\index{Rep@\texttt{Rep}}
\label{Rep}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape M}} is supposed to be a (non-zero) module defined over an order $\Lambda$. This method returns the images of the generators $\Lambda$ under the representation associated to \mbox{\texttt{\mdseries\slshape M}}. }

 

\subsection{\textcolor{Chapter }{ReduceModP}}
\logpage{[ 2, 1, 20 ]}\nobreak
\hyperdef{L}{X81F4814E83269C82}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ReduceModP({\mdseries\slshape M})\index{ReduceModP@\texttt{ReduceModP}}
\label{ReduceModP}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape M}} is supposed to be a module. This returns $M/pM$. }

 

\subsection{\textcolor{Chapter }{SubmoduleByBasisNC}}
\logpage{[ 2, 1, 21 ]}\nobreak
\hyperdef{L}{X8133D3468687AD8B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SubmoduleByBasisNC({\mdseries\slshape M, B})\index{SubmoduleByBasisNC@\texttt{SubmoduleByBasisNC}}
\label{SubmoduleByBasisNC}
}\hfill{\scriptsize (method)}}\\


 Given a module \mbox{\texttt{\mdseries\slshape M}} of dimension $n$ and an $n\times n$ matrix \mbox{\texttt{\mdseries\slshape B}} whose rowspace is a submodule of \mbox{\texttt{\mdseries\slshape M}} (this is not checked), this method will return the corresponding submodule (as
a module in the sense of this package). }

 

\subsection{\textcolor{Chapter }{MaximalSubmoduleBases}}
\logpage{[ 2, 1, 22 ]}\nobreak
\hyperdef{L}{X7ED27D2485D61669}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MaximalSubmoduleBases({\mdseries\slshape M[, S]})\index{MaximalSubmoduleBases@\texttt{MaximalSubmoduleBases}}
\label{MaximalSubmoduleBases}
}\hfill{\scriptsize (method)}}\\


 If \mbox{\texttt{\mdseries\slshape S}} is not specified, this will return a list consisting of tuples \texttt{[B,T]} (one for every maximal submodule of \mbox{\texttt{\mdseries\slshape M}}), where \texttt{B} is a basis matrix for a maximal submodule $N$ of \mbox{\texttt{\mdseries\slshape M}}, and \texttt{T} is a simple module isomorphic to the quotient $\mbox{\texttt{\mdseries\slshape M}}/N$. 

 If \mbox{\texttt{\mdseries\slshape S}} is given (a simple module is expected here), this will return a list of basis
matrices for all maximal submodules $N$ with $\mbox{\texttt{\mdseries\slshape M}}/N \cong \mbox{\texttt{\mdseries\slshape S}}$. 

 Whenever the zero module is a maximal submodule, its basis matrix will be
given by an empty list. }

 

\subsection{\textcolor{Chapter }{MaximalSubmoduleBasesMTX}}
\logpage{[ 2, 1, 23 ]}\nobreak
\hyperdef{L}{X83982AF587B1B130}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MaximalSubmoduleBasesMTX({\mdseries\slshape M})\index{MaximalSubmoduleBasesMTX@\texttt{MaximalSubmoduleBasesMTX}}
\label{MaximalSubmoduleBasesMTX}
}\hfill{\scriptsize (method)}}\\


 This returns a list of bases of all maximal submodules of the module \mbox{\texttt{\mdseries\slshape M}} using the \textsf{MeatAxe} that comes with \textsf{GAP}. This will only work if the generators of $\Lambda$ act as automorphisms on \mbox{\texttt{\mdseries\slshape M}}. Unsing this function is therefore not recommended, use \texttt{MaximalSubmoduleBases} (\ref{MaximalSubmoduleBases}) instead. }

 

\subsection{\textcolor{Chapter }{MaximalSubmodules}}
\logpage{[ 2, 1, 24 ]}\nobreak
\hyperdef{L}{X7E3FE8F883A5A3B8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MaximalSubmodules({\mdseries\slshape M[, S]})\index{MaximalSubmodules@\texttt{MaximalSubmodules}}
\label{MaximalSubmodules}
}\hfill{\scriptsize (method)}}\\


 Like \texttt{MaximalSubmoduleBases} (\ref{MaximalSubmoduleBases}), but instead of basis matrices, this function will return modules in the
sense of this package. }

 

\subsection{\textcolor{Chapter }{Hom}}
\logpage{[ 2, 1, 25 ]}\nobreak
\hyperdef{L}{X80015C78876B4F1E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Hom({\mdseries\slshape M, N})\index{Hom@\texttt{Hom}}
\label{Hom}
}\hfill{\scriptsize (method)}}\\


 Calculates a basis for the homomorphism space between the modules \mbox{\texttt{\mdseries\slshape M}} and \mbox{\texttt{\mdseries\slshape N}}. As any module in this package is canonically embedded in either some $\mathbb{Z}_p^{1\times n}$ or some $\mathbb{F}_p^{1\times n}$, this method will always return a list of matrices either defined over the
integers or over \texttt{GF(p)}. }

 

\subsection{\textcolor{Chapter }{HomToSimpleNC}}
\logpage{[ 2, 1, 26 ]}\nobreak
\hyperdef{L}{X80037271826B2FF8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{HomToSimpleNC({\mdseries\slshape M, S})\index{HomToSimpleNC@\texttt{HomToSimpleNC}}
\label{HomToSimpleNC}
}\hfill{\scriptsize (method)}}\\


 This is basically equivalent to \texttt{Hom} (\ref{Hom}), but it is assumed that \mbox{\texttt{\mdseries\slshape S}} is simple. This function uses the built-in \textsf{MeatAxe} of \textsf{GAP}, rendering it much faster than \texttt{Hom} (\ref{Hom}). }

 

\subsection{\textcolor{Chapter }{HomForLattices}}
\logpage{[ 2, 1, 27 ]}\nobreak
\hyperdef{L}{X81C93A707C017CF4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{HomForLattices({\mdseries\slshape M, N, opt})\index{HomForLattices@\texttt{HomForLattices}}
\label{HomForLattices}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape M}} and \mbox{\texttt{\mdseries\slshape N}} are supposed to be lattices defined over an order \texttt{lambda}. \mbox{\texttt{\mdseries\slshape opt}} is supposed to be one of \texttt{[ ]} (useless), \texttt{[ 1 ]} \texttt{[ 2 ]} or \texttt{[ 1, 2 ]} (although the ordering of the list is irrelevant). This function computes a
basis of $\textrm{Hom}(\mbox{\texttt{\mdseries\slshape M}},\mbox{\texttt{\mdseries\slshape N}})$ and will return a list containing the following: 
\begin{itemize}
\item  If $1\in\mbox{\texttt{\mdseries\slshape opt}}$: A basis of $\textrm{Hom}(M,N)$, as it would be returned by \texttt{Hom} (\ref{Hom}).
\item  If $2\in\mbox{\texttt{\mdseries\slshape opt}}$: A basis of $\textrm{Hom}(M,N)$ embedded in 
\[ \bigoplus_{i} \textrm{End}_{\mathbb{Q}_p\otimes \Lambda}(\mathbb{Q}_p\otimes
L_i)^{m_i\times n_i} \]
 where $L_i$ is the $i$-th irreducible lattice of the order $\Lambda$ (over which \mbox{\texttt{\mdseries\slshape M}} and \mbox{\texttt{\mdseries\slshape N}} are defined), as returned by \texttt{IrreducibleLattices} (\ref{IrreducibleLattices}). The elements of $\textrm{End}_{\mathbb{Q}_p\otimes \Lambda}(\mathbb{Q}_p\otimes L_i)$ are given by a (fixed) representation in some matrix ring over $\mathbb{Q}_p$. $m_i$ resp. $n_i$ denote the multiplicity of $\mathbb{Q}_p\otimes L_i$ as a summand of $\mathbb{Q}_p\otimes M$ resp. $\mathbb{Q}_p\otimes N$. 
\end{itemize}
 This function requires that some additional information about the lattices is
known, namely an embedding into a direct sum of irreducible lattices, as well
as the endomorphism rings of the latter (which is usually the case). If $1\in\mbox{\texttt{\mdseries\slshape opt}}$, you may check that this information is present via \texttt{IsBound(M!.embedding{\textunderscore}into{\textunderscore}irr{\textunderscore}lats)} and \texttt{IsBound(M!.order!.Qp{\textunderscore}end{\textunderscore}bases)}. If $2\in\mbox{\texttt{\mdseries\slshape opt}}$ we additionally require \texttt{IsBound(M!.Qp{\textunderscore}end{\textunderscore}bases{\textunderscore}smallmats)}. }

 

\subsection{\textcolor{Chapter }{RadicalOfModule}}
\logpage{[ 2, 1, 28 ]}\nobreak
\hyperdef{L}{X7E44920683157DE2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{RadicalOfModule({\mdseries\slshape M})\index{RadicalOfModule@\texttt{RadicalOfModule}}
\label{RadicalOfModule}
}\hfill{\scriptsize (method)}}\\


 Returns a tuple \texttt{[R, v]}, where \texttt{R} is a module isomorphic to $\textrm{Rad}(\mbox{\texttt{\mdseries\slshape M}})$. \texttt{v} will be a list of non-negative integers, each \texttt{v[i]} indicating the multiplicity of \texttt{SimpleModules(...)[i]} in $\mbox{\texttt{\mdseries\slshape M}}/\textrm{Rad}(\mbox{\texttt{\mdseries\slshape M}})$ }

 

\subsection{\textcolor{Chapter }{TopEpimorphism}}
\logpage{[ 2, 1, 29 ]}\nobreak
\hyperdef{L}{X84F41D288028219F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TopEpimorphism({\mdseries\slshape M})\index{TopEpimorphism@\texttt{TopEpimorphism}}
\label{TopEpimorphism}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape M}} is supposed to be a module. This returns a tuple $[Q,\phi,v,h]$, where $Q$ is a module isomorphic to $\mbox{\texttt{\mdseries\slshape M}} / \textrm{Rad} \mbox{\texttt{\mdseries\slshape M}}$ and $\phi: M \rightarrow Q$ is an epimorphism. Furthermore $v$ is a list of the multiplicities of the different simple modules in $Q$. $h$ is a list of $\textrm{End}(S)$-bases of $\textrm{Hom}(M, S)$ (for all simple modules $S$). }

 

\subsection{\textcolor{Chapter }{RadicalSeries}}
\logpage{[ 2, 1, 30 ]}\nobreak
\hyperdef{L}{X7929281B848A9FBE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{RadicalSeries({\mdseries\slshape M, k})\index{RadicalSeries@\texttt{RadicalSeries}}
\label{RadicalSeries}
}\hfill{\scriptsize (method)}}\\


 Calculates the first \mbox{\texttt{\mdseries\slshape k}} radical layers of \mbox{\texttt{\mdseries\slshape M}}. Returns a matrix \texttt{X} such that \texttt{X[j][i]} is equal to the multiplicity of \texttt{SimpleModules(...)[i]} in $\textrm{Rad}^{j-1}(M)/\textrm{Rad}^{j}(M)$ }

 

\subsection{\textcolor{Chapter }{GramMatrixOfTrace}}
\logpage{[ 2, 1, 31 ]}\nobreak
\hyperdef{L}{X78E0861E7CEE3540}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{GramMatrixOfTrace({\mdseries\slshape lambda, u})\index{GramMatrixOfTrace@\texttt{GramMatrixOfTrace}}
\label{GramMatrixOfTrace}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape u}} is supposed to be a list of rationals, the same numer of entries as \mbox{\texttt{\mdseries\slshape lambda}} has Wedderburn components (i. e. \mbox{\texttt{\mdseries\slshape u}} represents an element in $Z(\mathbb{Q}_p\otimes\mbox{\texttt{\mdseries\slshape lambda}})$). Return the Gram-matrix of \mbox{\texttt{\mdseries\slshape lambda}} with respect to the trace bilinear form $T_{\mbox{\texttt{\mdseries\slshape u}}}: (a,b)\mapsto \textrm{tr}(\mbox{\texttt{\mdseries\slshape u}}ab)$ and the basis of \mbox{\texttt{\mdseries\slshape lambda}} returned by \texttt{Generators} (\ref{Generators}). }

 }

 
\section{\textcolor{Chapter }{Endomorphism Rings of the Irreducible Lattices}}\label{Endo}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X817014A9873DB92E}{}
{
 Many functions in this package require that the endomorphism rings of the
irreducible lattices of an order are known. Unfortunately, at this point we
cannot effectively compute these in \textsf{GAP}. 

\subsection{\textcolor{Chapter }{InstallTrivialEndomorphismRings}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X8661E79280CE7F4A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{InstallTrivialEndomorphismRings({\mdseries\slshape lambda})\index{InstallTrivialEndomorphismRings@\texttt{InstallTrivialEndomorphismRings}}
\label{InstallTrivialEndomorphismRings}
}\hfill{\scriptsize (method)}}\\


 Call this function if you \emph{know} that $\mathbb{Q}_p$ is a splittiong field for $\mathbb{Q}_p\otimes\mbox{\texttt{\mdseries\slshape lambda}}$ }

 

\subsection{\textcolor{Chapter }{InstallEndomorphismRingsNC}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X7E720E8785EAFC01}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{InstallEndomorphismRingsNC({\mdseries\slshape lambda, lst})\index{InstallEndomorphismRingsNC@\texttt{InstallEndomorphismRingsNC}}
\label{InstallEndomorphismRingsNC}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape lst}} is supposed to be a list of bases of endomorphism rings (i. e. a list of lists
of matrices). You may for instance call \texttt{InstallEndomorphismRingsNC(lambda, List(IrreducibleLattices(lambda), L
-{\textgreater} Hom(L,L)))} to compute the endomorphism rings in \textsf{GAP} itself (this will however be horribly slow and excessive in memory usage). }

 

\subsection{\textcolor{Chapter }{CalculateEndomorphismRingsByReynoldsNC}}
\logpage{[ 2, 2, 3 ]}\nobreak
\hyperdef{L}{X841431788064377A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CalculateEndomorphismRingsByReynoldsNC({\mdseries\slshape lambda})\index{CalculateEndomorphismRingsByReynoldsNC@\texttt{Calculate}\-\texttt{Endomorphism}\-\texttt{Rings}\-\texttt{By}\-\texttt{ReynoldsNC}}
\label{CalculateEndomorphismRingsByReynoldsNC}
}\hfill{\scriptsize (method)}}\\


 This calculates endomorphism rings using the Reynolds \texttt{HomByReynoldsNC} (\ref{HomByReynoldsNC}). This only works if the generators of \texttt{lambda} generate a finite group (e.g. if \texttt{lambda} is a group algebra). }

 

\subsection{\textcolor{Chapter }{CalculateEndomorphismRingsWithMAGMA}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X7A89BE64821A10B2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CalculateEndomorphismRingsWithMAGMA({\mdseries\slshape lambda})\index{CalculateEndomorphismRingsWithMAGMA@\texttt{CalculateEndomorphismRingsWithMAGMA}}
\label{CalculateEndomorphismRingsWithMAGMA}
}\hfill{\scriptsize (method)}}\\


 This calculates endomorphism rings using \textsf{MAGMA}. Use \texttt{SetMAGMAExecutable} (\ref{SetMAGMAExecutable}) to specify the location of the \textsf{MAGMA}-executable on your system. }

 

\subsection{\textcolor{Chapter }{SetMAGMAExecutable}}
\logpage{[ 2, 2, 5 ]}\nobreak
\hyperdef{L}{X79BE448978FB33C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SetMAGMAExecutable({\mdseries\slshape cmd})\index{SetMAGMAExecutable@\texttt{SetMAGMAExecutable}}
\label{SetMAGMAExecutable}
}\hfill{\scriptsize (method)}}\\


 Use \texttt{cmd} to run \textsf{MAGMA}. }

 

\subsection{\textcolor{Chapter }{SetDebugOutput}}
\logpage{[ 2, 2, 6 ]}\nobreak
\hyperdef{L}{X84199ABF87A5579B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SetDebugOutput({\mdseries\slshape b})\index{SetDebugOutput@\texttt{SetDebugOutput}}
\label{SetDebugOutput}
}\hfill{\scriptsize (method)}}\\


 \texttt{b} is expected to be a boolean. This turn debugging output on or off (as some
computations take a long time, it can be useful to have some indication of how
the computation is progressing). }

 }

 
\section{\textcolor{Chapter }{Condensation for Group Algebras}}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X861303627B2C81AA}{}
{
 It is assumed throughout this section that the order $\Lambda$ we are dealing with is a group algebra (or a block of) $\mathbb{Z}_p G$ for some finite group $G$. It is furthermore assumed that the generators of $\Lambda$ are elements of $G$. 

\subsection{\textcolor{Chapter }{CondensationData}}
\logpage{[ 2, 3, 1 ]}\nobreak
\hyperdef{L}{X86812D218426AE41}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CondensationData({\mdseries\slshape G, H[, chi]})\index{CondensationData@\texttt{CondensationData}}
\label{CondensationData}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape H}} is supposed to be a $p'$-subgroup of \mbox{\texttt{\mdseries\slshape G}}. \mbox{\texttt{\mdseries\slshape chi}} is supposed to be a linear (i. e. one-dimensional) character of \mbox{\texttt{\mdseries\slshape H}}. If \mbox{\texttt{\mdseries\slshape chi}} is not given, it will be taken as the trivial character. This method then
computes a condensation idempotent $e_\chi$ belonging to the pair $(H,\chi)$ and a generating system for $e_\chi \mathbb{Z}_p G e_\chi$ (cf. \cite{Noeske}). }

 

\subsection{\textcolor{Chapter }{CondenseGroupRingNC}}
\logpage{[ 2, 3, 2 ]}\nobreak
\hyperdef{L}{X82C92CA486A7E6A6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CondenseGroupRingNC({\mdseries\slshape lambda[, gens], data})\index{CondenseGroupRingNC@\texttt{CondenseGroupRingNC}}
\label{CondenseGroupRingNC}
}\hfill{\scriptsize (method)}}\\


 Returns an order that is a condensation of \mbox{\texttt{\mdseries\slshape lambda}} with respect to the condensation idempotent and system of generators fixed in \mbox{\texttt{\mdseries\slshape data}}. \mbox{\texttt{\mdseries\slshape data}} should have been fixed via \texttt{CondensationData(...)}. The argument \mbox{\texttt{\mdseries\slshape gens}} should contain the images of the generators of $G$ (as returned by \texttt{GeneratorsOfGroup(G)}) in $\Lambda$ (i. e., \mbox{\texttt{\mdseries\slshape gens}} will be a list of lists of matrices). If \mbox{\texttt{\mdseries\slshape gens}} is not provided, it will be assumed that the images will be the generators of $\Lambda$ in the same order as they were given upon creation of \mbox{\texttt{\mdseries\slshape lambda}}. }

 

\subsection{\textcolor{Chapter }{CondensationProperties}}
\logpage{[ 2, 3, 3 ]}\nobreak
\hyperdef{L}{X852E219286128859}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CondensationProperties({\mdseries\slshape lambda[, gens], data})\index{CondensationProperties@\texttt{CondensationProperties}}
\label{CondensationProperties}
}\hfill{\scriptsize (method)}}\\


 This function is analogous to \texttt{CondenseGroupRingNC} (\ref{CondenseGroupRingNC}), except that it actually just calculates which simple torsion-modules and
which irreducible ordinary representations are annihilated by the selected
condensation idempotent. You may use this to check wether the condensation
will be faithful. }

 

\subsection{\textcolor{Chapter }{CondenseMatricesNC}}
\logpage{[ 2, 3, 4 ]}\nobreak
\hyperdef{L}{X7A54F9257C8616E3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CondenseMatricesNC({\mdseries\slshape Ggens, Greps, data})\index{CondenseMatricesNC@\texttt{CondenseMatricesNC}}
\label{CondenseMatricesNC}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape Ggens}} is supposed to be a list of generators of a group $G$, \mbox{\texttt{\mdseries\slshape Greps}} is supposed to be a list of matrices (defined over the integers) of the same
length as \mbox{\texttt{\mdseries\slshape Ggens}}. The first to arguments should define a representation of the group in
question, i. e., the map sending \texttt{\mbox{\texttt{\mdseries\slshape Ggens}}[i]} to \texttt{\mbox{\texttt{\mdseries\slshape Greps}}[i]} extends to a representation of $G$. \mbox{\texttt{\mdseries\slshape data}} is supposed to be a record generated by \texttt{CondensationData} (\ref{CondensationData}). This will return a list \texttt{[cgens, base, baseR]}. \texttt{cgens} will contain the images of the generators of the condesed algebra (as fixed in \mbox{\texttt{\mdseries\slshape data}}) under the condensed representation. \texttt{base} will be an embedding of the condensed representation into the uncondensed, and \texttt{baseR} will be a right inverse of \texttt{base}. }

 

\subsection{\textcolor{Chapter }{CondenseMatricesWithEvalMapNC}}
\logpage{[ 2, 3, 5 ]}\nobreak
\hyperdef{L}{X877AC25E7F9A8F9F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CondenseMatricesWithEvalMapNC({\mdseries\slshape hom, data})\index{CondenseMatricesWithEvalMapNC@\texttt{CondenseMatricesWithEvalMapNC}}
\label{CondenseMatricesWithEvalMapNC}
}\hfill{\scriptsize (function)}}\\


 Just like \texttt{CondenseMatricesNC} (\ref{CondenseMatricesNC}), but instead of the arguments \texttt{Ggens} and \texttt{Greps} you specify a function \mbox{\texttt{\mdseries\slshape hom}} which will return for any element in the group its image under the
representation you wish to condense. }

 

\subsection{\textcolor{Chapter }{CondenseTorsionRepNC}}
\logpage{[ 2, 3, 6 ]}\nobreak
\hyperdef{L}{X7BE15B3B82139138}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CondenseTorsionRepNC({\mdseries\slshape Ggens, Greps, p, data})\index{CondenseTorsionRepNC@\texttt{CondenseTorsionRepNC}}
\label{CondenseTorsionRepNC}
}\hfill{\scriptsize (method)}}\\


 Just like \texttt{CondenseMatricesNC} (\ref{CondenseMatricesNC}), but for \mbox{\texttt{\mdseries\slshape p}}-modular representations instead of integral ones. }

 }

 
\section{\textcolor{Chapter }{Projective Modules \& Basic Algebras}}\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X7A802E898553AA42}{}
{
 

\subsection{\textcolor{Chapter }{ProjectiveIndecomposableLattices}}
\logpage{[ 2, 4, 1 ]}\nobreak
\hyperdef{L}{X7C656E4F85EA55BB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProjectiveIndecomposableLattices({\mdseries\slshape lambda})\index{ProjectiveIndecomposableLattices@\texttt{ProjectiveIndecomposableLattices}}
\label{ProjectiveIndecomposableLattices}
}\hfill{\scriptsize (method)}}\\


 Calculates the projective indecomposable lattices for \mbox{\texttt{\mdseries\slshape lambda}}. It will return a list cof tuples, where the first entry is a projective
indecomposable lattice, and the second one a simple torsion module (its head).
Depending on the dimensions of the projective indecomposables, running this
method may take some time. }

 

\subsection{\textcolor{Chapter }{BasicOrder}}
\logpage{[ 2, 4, 2 ]}\nobreak
\hyperdef{L}{X80A80EA6836FD57F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BasicOrder({\mdseries\slshape lambda})\index{BasicOrder@\texttt{BasicOrder}}
\label{BasicOrder}
}\hfill{\scriptsize (method)}}\\


 This calculates a basic algebra for \mbox{\texttt{\mdseries\slshape lambda}}. This method calls \texttt{ProjectiveIndecomposableLattices} (\ref{ProjectiveIndecomposableLattices}), and thus may take some time. The generators of the result will form a basis
of the order. Names given to the simple modules and Wedderburn components will
be carried over accordingly. }

 

\subsection{\textcolor{Chapter }{BasicOrder}}
\logpage{[ 2, 4, 3 ]}\nobreak
\hyperdef{L}{X80A80EA6836FD57F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BasicOrder({\mdseries\slshape lst})\index{BasicOrder@\texttt{BasicOrder}}
\label{BasicOrder}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape lst}} should be a list of projective indecomposable lattices. It will return an
order isomorphic to 
\[ \bigoplus_{P, Q \in \mbox{\texttt{\mdseries\slshape lst}}} \textrm{Hom}(P, Q) \]
 and carry over names accrodingly. If \mbox{\texttt{\mdseries\slshape lst}} is a list of all projective indecomposables, this is just equivalent to \texttt{BasicOrder(lambda)}. }

 

\subsection{\textcolor{Chapter }{ProjectiveIndecomposableForBasicOrder}}
\logpage{[ 2, 4, 4 ]}\nobreak
\hyperdef{L}{X7B21D84684A32CAC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProjectiveIndecomposableForBasicOrder({\mdseries\slshape lambda, k})\index{ProjectiveIndecomposableForBasicOrder@\texttt{Projective}\-\texttt{Indecomposable}\-\texttt{For}\-\texttt{Basic}\-\texttt{Order}}
\label{ProjectiveIndecomposableForBasicOrder}
}\hfill{\scriptsize (method)}}\\


 This will construct the projective indecomposable lattive with head \texttt{SimpleModules(\mbox{\texttt{\mdseries\slshape lambda}})[k]}. This method just uses (in contrast to \texttt{ProjectiveIndecomposableLattices} (\ref{ProjectiveIndecomposableLattices})) the regular representation of \mbox{\texttt{\mdseries\slshape lambda}}. \mbox{\texttt{\mdseries\slshape lambda}} should be an order constructed via \texttt{BasicOrder} (\ref{BasicOrder}) (this is not checked though). }

 

\subsection{\textcolor{Chapter }{ProjectiveIndecomposableLatticesForBasicOrder}}
\logpage{[ 2, 4, 5 ]}\nobreak
\hyperdef{L}{X81E606D77BAFD83B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProjectiveIndecomposableLatticesForBasicOrder({\mdseries\slshape lambda})\index{ProjectiveIndecomposableLatticesForBasicOrder@\texttt{Projective}\-\texttt{Indecomposable}\-\texttt{Lattices}\-\texttt{For}\-\texttt{Basic}\-\texttt{Order}}
\label{ProjectiveIndecomposableLatticesForBasicOrder}
}\hfill{\scriptsize (method)}}\\


 This behaves like \texttt{ProjectiveIndecomposableLattices} (\ref{ProjectiveIndecomposableLattices}), but will make use of \texttt{ProjectiveIndecomposableForBasicOrder} (\ref{ProjectiveIndecomposableForBasicOrder}). In particular, \mbox{\texttt{\mdseries\slshape lambda}} should be an order constructed via \texttt{BasicOrder} (\ref{BasicOrder}). }

 

\subsection{\textcolor{Chapter }{GeneratorsForBasicOrder}}
\logpage{[ 2, 4, 6 ]}\nobreak
\hyperdef{L}{X7EEF97F381D74420}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{GeneratorsForBasicOrder({\mdseries\slshape lambda})\index{GeneratorsForBasicOrder@\texttt{GeneratorsForBasicOrder}}
\label{GeneratorsForBasicOrder}
}\hfill{\scriptsize (method)}}\\


 This will calculate a minimal (w.r.t. inclusion) generating system for \mbox{\texttt{\mdseries\slshape lambda}} (that will be preimages of a basis of $\Lambda/\textrm{Jac}(\Lambda)$ and of a basis of $\textrm{Jac}(\Lambda)\textrm{Jac}^2(\Lambda)+p\Lambda$). \mbox{\texttt{\mdseries\slshape lambda}} should be an order constructed via \texttt{BasicOrder} (\ref{BasicOrder}) (this is not checked though). This method returns a list consisting of an
order and a function. The order will in the mathematical sense be equal to \mbox{\texttt{\mdseries\slshape lambda}}, but will have the calculated generating set as its set of generators. The
function that is returned can be applied to modules defined over \mbox{\texttt{\mdseries\slshape lambda}}, and will return the same module defined over the order that was returned. }

 }

 
\section{\textcolor{Chapter }{Computing with Lattices}}\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X8149E829843C9583}{}
{
 

\subsection{\textcolor{Chapter }{AllLattices}}
\logpage{[ 2, 5, 1 ]}\nobreak
\hyperdef{L}{X7B623B467A8EAF58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{AllLattices({\mdseries\slshape L})\index{AllLattices@\texttt{AllLattices}}
\label{AllLattices}
}\hfill{\scriptsize (method)}}\\


 If \texttt{L} is a lattice over an order, this function computes representatives for the
isomorphism classes of full sublattices of \texttt{L}, or, equivalently, for all lattices in the $\mathbb Q_p$-span of \texttt{L}. }

 

\subsection{\textcolor{Chapter }{AllLatticesInd}}
\logpage{[ 2, 5, 2 ]}\nobreak
\hyperdef{L}{X79620EF985031A25}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{AllLatticesInd({\mdseries\slshape L1, L2})\index{AllLatticesInd@\texttt{AllLatticesInd}}
\label{AllLatticesInd}
}\hfill{\scriptsize (method)}}\\


 If \texttt{L1} and \texttt{L2} are lattices over the same order, this function computes representatives for
the isomorphism classes of full sublattices of \texttt{DirectSumOfModules(L1,L2)} whose projection down to \texttt{L1} and \texttt{L2} is all of \texttt{L1} and \texttt{L2}, respectively. }

 

\subsection{\textcolor{Chapter }{IsomorphismRModules}}
\logpage{[ 2, 5, 3 ]}\nobreak
\hyperdef{L}{X79C753347B6257FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsomorphismRModules({\mdseries\slshape L1, L2})\index{IsomorphismRModules@\texttt{IsomorphismRModules}}
\label{IsomorphismRModules}
}\hfill{\scriptsize (method)}}\\


 If \texttt{L1} and \texttt{L2} are lattices over the same order, this function returns an isomorpism between \texttt{L1} and \texttt{L2} if the two lattices are isomorphic, and \texttt{fail} if they are not. }

 

\subsection{\textcolor{Chapter }{LatticeAlgorithm}}
\logpage{[ 2, 5, 4 ]}\nobreak
\hyperdef{L}{X7B2109F2873D555A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LatticeAlgorithm({\mdseries\slshape M, b})\index{LatticeAlgorithm@\texttt{LatticeAlgorithm}}
\label{LatticeAlgorithm}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape M}} is supposed to be an irreducible lattice (this will not be checked, but if it
is not irreducible, this function will not terminate) and \mbox{\texttt{\mdseries\slshape b}} should be a boolean. What is returned depends on \mbox{\texttt{\mdseries\slshape b}}: 
\begin{itemize}
\item \texttt{\mbox{\texttt{\mdseries\slshape b}} = false}: In this case, this function calculates representatives (possibly with
repetitions) of all isomorphism classes of irreducible lattices in $\mathbb{Q}_p\otimes M$. It return a list of basis matrices for these as sublattices of \mbox{\texttt{\mdseries\slshape M}}.
\item \texttt{\mbox{\texttt{\mdseries\slshape b}} = true}: In this case, this function will return only representatives of lattices
with simple top. The result will be a list of tuples, where the first entry is
a basis matrix, and the second entry is a simple module (the top of the
lattice).
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{LatticesWithSimpleRadQuo}}
\logpage{[ 2, 5, 5 ]}\nobreak
\hyperdef{L}{X7D833ACE835B36F4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LatticesWithSimpleRadQuo({\mdseries\slshape M})\index{LatticesWithSimpleRadQuo@\texttt{LatticesWithSimpleRadQuo}}
\label{LatticesWithSimpleRadQuo}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape M}} is supposed to be an irreducible lattice. This returns representatives
(possibly with repititions) of all irreducible lattices with simple top in $\mathbb{Q}_p\otimes M$. It return a list of tuples, where the first entry is a lattice and the
second one its top. }

 

\subsection{\textcolor{Chapter }{GlueUpNC}}
\logpage{[ 2, 5, 6 ]}\nobreak
\hyperdef{L}{X801AB72B841DA58B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{GlueUpNC({\mdseries\slshape P, Q, S})\index{GlueUpNC@\texttt{GlueUpNC}}
\label{GlueUpNC}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape P}} and \mbox{\texttt{\mdseries\slshape Q}} are supposed to be lattices, and \mbox{\texttt{\mdseries\slshape S}} is supposed to be a simple module. Under the assumption that \mbox{\texttt{\mdseries\slshape P}} and \mbox{\texttt{\mdseries\slshape Q}} both have simple top isomorphic to \mbox{\texttt{\mdseries\slshape S}} and furthermore \mbox{\texttt{\mdseries\slshape P}} and \mbox{\texttt{\mdseries\slshape Q}} have no non-zero common $\mathbb{Z}_p$-torsionfree image this method will return a (full) lattice with simple top \mbox{\texttt{\mdseries\slshape S}} in $\mbox{\texttt{\mdseries\slshape P}}\oplus \mbox{\texttt{\mdseries\slshape Q}}$. If the assumptions are not met, this method may not terminate. }

 }

 
\section{\textcolor{Chapter }{Basic Homological Algebra}}\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X85D2A39F86F250F3}{}
{
 

\subsection{\textcolor{Chapter }{ProjectiveCover}}
\logpage{[ 2, 6, 1 ]}\nobreak
\hyperdef{L}{X83257E2F7F8E0068}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProjectiveCover({\mdseries\slshape M})\index{ProjectiveCover@\texttt{ProjectiveCover}}
\label{ProjectiveCover}
}\hfill{\scriptsize (method)}}\\


 Given the module \mbox{\texttt{\mdseries\slshape M}}, this returns a tuple $[P, \phi]$. Here $P$ is the projective cover of \mbox{\texttt{\mdseries\slshape M}}, and $\phi$ is an epimorphism $P \rightarrow \mbox{\texttt{\mdseries\slshape M}}$. }

 

\subsection{\textcolor{Chapter }{LiftHomomorphismNC}}
\logpage{[ 2, 6, 2 ]}\nobreak
\hyperdef{L}{X7D58BC08870B8DAB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LiftHomomorphismNC({\mdseries\slshape M, phi, N, psi, L})\index{LiftHomomorphismNC@\texttt{LiftHomomorphismNC}}
\label{LiftHomomorphismNC}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape M}}, \mbox{\texttt{\mdseries\slshape N}} and \mbox{\texttt{\mdseries\slshape L}} are supposed to be modules. \mbox{\texttt{\mdseries\slshape phi}} is supposed to be a homomorphism $\mbox{\texttt{\mdseries\slshape M}}\rightarrow\mbox{\texttt{\mdseries\slshape L}}$. \mbox{\texttt{\mdseries\slshape psi}} is supposed to be a homomorphism $\mbox{\texttt{\mdseries\slshape N}}\rightarrow\mbox{\texttt{\mdseries\slshape L}}$. This return a homomorphism $X: M \rightarrow N$ such that $X \cdot \mbox{\texttt{\mdseries\slshape psi}} = \mbox{\texttt{\mdseries\slshape phi}}$. If no such $X$ exists, \texttt{fail} is returned. Note that all homomorphisms are represented by matrices, and it
is not checked wether the given matrices actually are homomorphisms. }

 

\subsection{\textcolor{Chapter }{LiftHomomorphismToDirectSumNC}}
\logpage{[ 2, 6, 3 ]}\nobreak
\hyperdef{L}{X7B23D510794F451E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LiftHomomorphismToDirectSumNC({\mdseries\slshape lst, svec, phi, N, psi, L})\index{LiftHomomorphismToDirectSumNC@\texttt{LiftHomomorphismToDirectSumNC}}
\label{LiftHomomorphismToDirectSumNC}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape lst}} is supposed to be a list of lattices. \mbox{\texttt{\mdseries\slshape svec}} is supposed to be a list of indices. This is then equivalent to calling \texttt{LiftHomomorphismNC(DirectSumOfModules(List(svec, i -{\textgreater} lst[i])),
phi, N, psi, L)} but it is actually a lot faster. }

 

\subsection{\textcolor{Chapter }{HellerTranslate}}
\logpage{[ 2, 6, 4 ]}\nobreak
\hyperdef{L}{X8720150D824FA283}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{HellerTranslate({\mdseries\slshape M})\index{HellerTranslate@\texttt{HellerTranslate}}
\label{HellerTranslate}
}\hfill{\scriptsize (method)}}\\


 Given a module \mbox{\texttt{\mdseries\slshape M}}, this computes its Heller translate. Note that this is always going to return
a lattice. }

 

\subsection{\textcolor{Chapter }{HellerTranslateModular}}
\logpage{[ 2, 6, 5 ]}\nobreak
\hyperdef{L}{X7FBAB232837856CA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{HellerTranslateModular({\mdseries\slshape M})\index{HellerTranslateModular@\texttt{HellerTranslateModular}}
\label{HellerTranslateModular}
}\hfill{\scriptsize (method)}}\\


 Given a torsion module \mbox{\texttt{\mdseries\slshape M}}, this computes its modular Heller translate. That is, the Heller translate in
the module category of $\mathbb{F}_p \otimes \Lambda$, where $\Lambda$ denotes the order over which \mbox{\texttt{\mdseries\slshape M}} is defined. Note that this is always going to return a torsion module. }

 }

 
\section{\textcolor{Chapter }{Input/Output}}\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X7C6B4235806BA0E9}{}
{
 

\subsection{\textcolor{Chapter }{PrintAsFunction}}
\logpage{[ 2, 7, 1 ]}\nobreak
\hyperdef{L}{X862DBD84783F0CF6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PrintAsFunction({\mdseries\slshape X})\index{PrintAsFunction@\texttt{PrintAsFunction}}
\label{PrintAsFunction}
}\hfill{\scriptsize (method)}}\\


 Outputs a function that will create the module or order \mbox{\texttt{\mdseries\slshape X}}. Usually you would use \texttt{SaveAsFunction} (\ref{SaveAsFunction}) directly. }

 

\subsection{\textcolor{Chapter }{SaveAsFunction}}
\logpage{[ 2, 7, 2 ]}\nobreak
\hyperdef{L}{X866F4E7886604DCC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SaveAsFunction({\mdseries\slshape filename, X})\index{SaveAsFunction@\texttt{SaveAsFunction}}
\label{SaveAsFunction}
}\hfill{\scriptsize (method)}}\\


 Saves the module or order \mbox{\texttt{\mdseries\slshape X}} to the file \mbox{\texttt{\mdseries\slshape filename}} (which will be overwritten in case it exists). You can then read that file
using \texttt{ReadOrder} (\ref{ReadOrder}) or \texttt{ReadModule} (\ref{ReadModule}). }

 

\subsection{\textcolor{Chapter }{SaveAsRecord}}
\logpage{[ 2, 7, 3 ]}\nobreak
\hyperdef{L}{X79579D7B7BA0DD1F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SaveAsRecord({\mdseries\slshape filename, lambda})\index{SaveAsRecord@\texttt{SaveAsRecord}}
\label{SaveAsRecord}
}\hfill{\scriptsize (method)}}\\


 This writes the order \mbox{\texttt{\mdseries\slshape lambda}} to the file \mbox{\texttt{\mdseries\slshape filename}} (which will be overwritten in case it exists). The file will then contain a \textsf{GAP}-function that returns a record. The content of that file cannot be turned
back into an order directly using this package, so usually you would want to
use \texttt{SaveAsFunction} (\ref{SaveAsFunction}). However, the advantage of \texttt{SaveAsRecord} is that you do not need this package to read the file that it produces. }

 

\subsection{\textcolor{Chapter }{ReadOrder}}
\logpage{[ 2, 7, 4 ]}\nobreak
\hyperdef{L}{X801F19247F5FF96C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ReadOrder({\mdseries\slshape filename})\index{ReadOrder@\texttt{ReadOrder}}
\label{ReadOrder}
}\hfill{\scriptsize (method)}}\\


 Returns an order that is identical to the one that was written to \mbox{\texttt{\mdseries\slshape filename}} using \texttt{SaveAsFunction} (\ref{SaveAsFunction}). }

 

\subsection{\textcolor{Chapter }{ReadModule}}
\logpage{[ 2, 7, 5 ]}\nobreak
\hyperdef{L}{X82F06F3E7C01027B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ReadModule({\mdseries\slshape filename, lambda})\index{ReadModule@\texttt{ReadModule}}
\label{ReadModule}
}\hfill{\scriptsize (method)}}\\


 Returns a module that is identical to the one that was written to \mbox{\texttt{\mdseries\slshape filename}} using \texttt{SaveAsFunction} (\ref{SaveAsFunction}). That module will be defined over \mbox{\texttt{\mdseries\slshape lambda}} (so when you save a module be sure to always save the order over which it is
defined as well). }

 }

 
\section{\textcolor{Chapter }{Symmetric Groups}}\logpage{[ 2, 8, 0 ]}
\hyperdef{L}{X7BE4F15F78127B12}{}
{
 

\subsection{\textcolor{Chapter }{ZpSn}}
\logpage{[ 2, 8, 1 ]}\nobreak
\hyperdef{L}{X8704216079C88EF2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ZpSn({\mdseries\slshape p, n})\index{ZpSn@\texttt{ZpSn}}
\label{ZpSn}
}\hfill{\scriptsize (function)}}\\


 This returns the order $\mathbb{Z}_p \Sigma_n$. The Wedderburn components are named by partitions, and sorted descending
with respect to the lexicographical ordering. The simple modules are named
after their dimensions (it will not be too hard to find the corresponding \mbox{\texttt{\mdseries\slshape p}}-regular partitions, though). The lattices returned by \texttt{IrreducibleLattices} (\ref{IrreducibleLattices}) will be the Specht lattices. }

 

\subsection{\textcolor{Chapter }{ZpSnWedderburnComponentsNC}}
\logpage{[ 2, 8, 2 ]}\nobreak
\hyperdef{L}{X7E2A03CA7E6A7730}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ZpSnWedderburnComponentsNC({\mdseries\slshape p, part})\index{ZpSnWedderburnComponentsNC@\texttt{ZpSnWedderburnComponentsNC}}
\label{ZpSnWedderburnComponentsNC}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape part}} is supposed to be a non-empty list of pairwise distinct partitions of the same
number $n$ (this will however not be checked). Returns the projection of $\mathbb{Z}_p \Sigma_n$ on the Wedderburn components labeled by the partitons in \mbox{\texttt{\mdseries\slshape part}}. Otherwise this behaves like \texttt{ZpSn} (\ref{ZpSn}). }

 

\subsection{\textcolor{Chapter }{NaturalSpechtRepresentation}}
\logpage{[ 2, 8, 3 ]}\nobreak
\hyperdef{L}{X7A2B1B1B8732CA08}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NaturalSpechtRepresentation({\mdseries\slshape lambda})\index{NaturalSpechtRepresentation@\texttt{NaturalSpechtRepresentation}}
\label{NaturalSpechtRepresentation}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape lambda}} is supposed to be a partition of some positive integer \texttt{n}. This function returns a group homomorphism from \texttt{SymmetricGroup(n)} into a general linear group over the integers. To be more precise, this
function implements Young's "natural" representation for the Specht module $S^\lambda$. See Example 25.2 in \cite{James} for details. }

 

\subsection{\textcolor{Chapter }{PartitionAsString}}
\logpage{[ 2, 8, 4 ]}\nobreak
\hyperdef{L}{X7A9AC27C7C5F06C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PartitionAsString({\mdseries\slshape mu})\index{PartitionAsString@\texttt{PartitionAsString}}
\label{PartitionAsString}
}\hfill{\scriptsize (method)}}\\


 Given a partition \mbox{\texttt{\mdseries\slshape mu}}, this returns a string representing \mbox{\texttt{\mdseries\slshape mu}}. For instance \texttt{PartitionAsString([3,2,1,1])} returns \texttt{"(3,2,1\texttt{\symbol{94}}\texttt{\symbol{123}}2\texttt{\symbol{125}})"}. }

 }

 
\section{\textcolor{Chapter }{Experimental Functionality}}\logpage{[ 2, 9, 0 ]}
\hyperdef{L}{X869820BB7CEDAB7E}{}
{
 The functions in this section are somewhat experimental and only work
reasonably well in small examples. All functions in this section do
furthermore require that the generators of the given orders form a basis. 

\subsection{\textcolor{Chapter }{SelfdualSuborders}}
\logpage{[ 2, 9, 1 ]}\nobreak
\hyperdef{L}{X792F17BA8110DDAE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SelfdualSuborders({\mdseries\slshape lambda, u})\index{SelfdualSuborders@\texttt{SelfdualSuborders}}
\label{SelfdualSuborders}
}\hfill{\scriptsize (method)}}\\


 Given an element $u$ in $Z(\mathbb{Q}_p\otimes\mbox{\texttt{\mdseries\slshape lambda}})$, this returns all (ismomorphism classes of) orders contained in \mbox{\texttt{\mdseries\slshape lambda}} that are selfdual with respect to the trace bilinear form $T_u$ (same as in \texttt{GramMatrixOfTrace} (\ref{GramMatrixOfTrace})). }

 

\subsection{\textcolor{Chapter }{AreConjugate}}
\logpage{[ 2, 9, 2 ]}\nobreak
\hyperdef{L}{X7C58A90780B9708E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{AreConjugate({\mdseries\slshape lambda, gamma})\index{AreConjugate@\texttt{AreConjugate}}
\label{AreConjugate}
}\hfill{\scriptsize (method)}}\\


 Given two orders \mbox{\texttt{\mdseries\slshape lambda}} and \mbox{\texttt{\mdseries\slshape gamma}} in the same semisimple $\mathbb{Q}_p$-algebra $A$, this decides wether the two are conjugate (or, equivalently, isomorphic as
algebras over the center of $A$). }

 }

 
\section{\textcolor{Chapter }{Pretty Output}}\logpage{[ 2, 10, 0 ]}
\hyperdef{L}{X7880CD1F7F40DEDF}{}
{
 

\subsection{\textcolor{Chapter }{PrintDecompositionMatrixAsLatex}}
\logpage{[ 2, 10, 1 ]}\nobreak
\hyperdef{L}{X7AC57DA682D46286}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PrintDecompositionMatrixAsLatex({\mdseries\slshape A})\index{PrintDecompositionMatrixAsLatex@\texttt{PrintDecompositionMatrixAsLatex}}
\label{PrintDecompositionMatrixAsLatex}
}\hfill{\scriptsize (function)}}\\


 Given an order \texttt{A}, this function prints the decomposition matrix of \texttt{A} as \textsf{LaTeX}-code (including information on names and dimensions of modules). }

 

\subsection{\textcolor{Chapter }{PrintBasisOfOrderAsMarkdown}}
\logpage{[ 2, 10, 2 ]}\nobreak
\hyperdef{L}{X794F5D34802E99EC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PrintBasisOfOrderAsMarkdown({\mdseries\slshape A})\index{PrintBasisOfOrderAsMarkdown@\texttt{PrintBasisOfOrderAsMarkdown}}
\label{PrintBasisOfOrderAsMarkdown}
}\hfill{\scriptsize (function)}}\\


 Given a basic order \texttt{A}, this function prints a basis of \texttt{A} as \textsf{Jupyter}-markdown code (can easily be turned into \textsf{LaTeX}-code). }

 

\subsection{\textcolor{Chapter }{JupyterDisplayDecompositionMatrix}}
\logpage{[ 2, 10, 3 ]}\nobreak
\hyperdef{L}{X7B77CC9287A8D6DA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{JupyterDisplayDecompositionMatrix({\mdseries\slshape A})\index{JupyterDisplayDecompositionMatrix@\texttt{JupyterDisplayDecompositionMatrix}}
\label{JupyterDisplayDecompositionMatrix}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{JupyterDisplayBasisOfOrder({\mdseries\slshape A})\index{JupyterDisplayBasisOfOrder@\texttt{JupyterDisplayBasisOfOrder}}
\label{JupyterDisplayBasisOfOrder}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{JupyterDisplayMultiMatrix({\mdseries\slshape lst})\index{JupyterDisplayMultiMatrix@\texttt{JupyterDisplayMultiMatrix}}
\label{JupyterDisplayMultiMatrix}
}\hfill{\scriptsize (function)}}\\


 If \textsf{GAP} is run in a Jupyter notebook, this will render the respective objects in the
notebook. }

 }

 
\section{\textcolor{Chapter }{Miscellaneous Other Functions}}\logpage{[ 2, 11, 0 ]}
\hyperdef{L}{X858EC39F81ADB77F}{}
{
 

\subsection{\textcolor{Chapter }{SpinningAlgorithmNC}}
\logpage{[ 2, 11, 1 ]}\nobreak
\hyperdef{L}{X85E7705F8780EBC9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SpinningAlgorithmNC({\mdseries\slshape lst})\index{SpinningAlgorithmNC@\texttt{SpinningAlgorithmNC}}
\label{SpinningAlgorithmNC}
}\hfill{\scriptsize (function)}}\\


 Given a list \texttt{lst} of rational square matrices that generate a $\mathbb Z$-order, this function return a list \texttt{ret} of integer square matrices such that $T^{-1}\cdot \texttt{lst}[i] \cdot T = \texttt{ret}[i] \ \forall i$ for an invertible rational matrix $T$. }

 

\subsection{\textcolor{Chapter }{UnFlattenMultiMatrixNC}}
\logpage{[ 2, 11, 2 ]}\nobreak
\hyperdef{L}{X83CC7CF080ED97EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnFlattenMultiMatrixNC({\mdseries\slshape lst, dimvec})\index{UnFlattenMultiMatrixNC@\texttt{UnFlattenMultiMatrixNC}}
\label{UnFlattenMultiMatrixNC}
}\hfill{\scriptsize (function)}}\\


 When $A=[A_1,\ldots,A_k]$ is a list of matrices of dimensions $\mbox{\texttt{\mdseries\slshape dimvec}}=[n_1,\ldots,n_k]$, this method is inverse to \texttt{Flat(...)}, i. e. \texttt{UnFlattenMultiMatrixNC(Flat(A), dimvec) = A}. }

 

\subsection{\textcolor{Chapter }{DiagonalJoin}}
\logpage{[ 2, 11, 3 ]}\nobreak
\hyperdef{L}{X8138410E7C0258CA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagonalJoin({\mdseries\slshape lst})\index{DiagonalJoin@\texttt{DiagonalJoin}}
\label{DiagonalJoin}
}\hfill{\scriptsize (method)}}\\


 \mbox{\texttt{\mdseries\slshape lst}} is supposed to be a list $[A_1,\ldots,A_k]$, and the method returns $\textrm{Diag}(A_1,\ldots,A_k)$ }

 

\subsection{\textcolor{Chapter }{DiagonalJoin}}
\logpage{[ 2, 11, 4 ]}\nobreak
\hyperdef{L}{X8138410E7C0258CA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagonalJoin({\mdseries\slshape A, B})\index{DiagonalJoin@\texttt{DiagonalJoin}}
\label{DiagonalJoin}
}\hfill{\scriptsize (method)}}\\


 The same as above, for just two matrices. }

 

\subsection{\textcolor{Chapter }{Valuation}}
\logpage{[ 2, 11, 5 ]}\nobreak
\hyperdef{L}{X80D67BB67A509A56}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Valuation({\mdseries\slshape r, p})\index{Valuation@\texttt{Valuation}}
\label{Valuation}
}\hfill{\scriptsize (method)}}\\


 Returns the \mbox{\texttt{\mdseries\slshape p}}-valuation of the rational number \mbox{\texttt{\mdseries\slshape r}} (the built-in method in \textsf{GAP} only covers integers). }

 

\subsection{\textcolor{Chapter }{RightInverse}}
\logpage{[ 2, 11, 6 ]}\nobreak
\hyperdef{L}{X87614CA48493B63F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{RightInverse({\mdseries\slshape M})\index{RightInverse@\texttt{RightInverse}}
\label{RightInverse}
}\hfill{\scriptsize (method)}}\\


 Computes a right inverse of the matrix \mbox{\texttt{\mdseries\slshape M}} (over \texttt{DefaultFieldOfMatrix(M)}). If \mbox{\texttt{\mdseries\slshape M}} has no right inverse, it returns \texttt{fail}. }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{orders.bib}

\addcontentsline{toc}{chapter}{References}

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
